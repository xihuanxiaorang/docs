# 组件基础

组件允许我们将 UI 划分为**独立的**、**可重用**的部分，并且可以对每个部分进行单独的思考。在实际应用中，**组件常常被组织成层层嵌套的树状结构
**：<br />![组件树](https://cdn.jsdelivr.net/gh/xihuanxiaorang/img/202403151722334.png)

这和我们嵌套 HTML 元素的方式类似，Vue 实现了自己的组件模型，使我们可以**在每个组件内封装自定义内容与逻辑**。Vue 同样也能很好地配合原生
Web Component。如果你想知道 Vue 组件与原生 Web Components
之间的关系，可以[阅读此章节](https://cn.vuejs.org/guide/extras/web-components.html)。

## 定义一个组件

当使用构建步骤时，我们一般会将 Vue 组件定义在一个单独的 `.vue`
文件中，这被叫做[单文件组件](https://cn.vuejs.org/guide/scaling-up/sfc.html) (简称 SFC)：

```vue

<script setup>
  import {ref} from 'vue'

  const count = ref(0)
</script>

<template>
  <button @click="count++">You clicked me {{ count }} times.</button>
</template>
```

当不使用构建步骤时，**一个 Vue 组件以一个包含 Vue 特定选项的 JavaScript 对象来定义**：

```js
import {ref} from 'vue'

export default {
  setup() {
    const count = ref(0)
    return {count}
  },
  template: `
    <button @click="count++">
      You clicked me {{ count }} times.
    </button>`
  // 也可以针对一个 DOM 内联模板：
  // template: '#my-template-element'
}
```

这里的模板**是一个内联的 JavaScript 字符串，Vue 将会在运行时编译它**。你**也可以使用 ID 选择器来指向一个元素 (
通常是原生的 `<template>` 元素)，Vue 将会使用其内容作为模板来源**。

上面的例子中定义了一个组件，并**在一个 `.js` 文件里默认导出了它自己**，但你**也可以通过具名导出在一个文件中导出多个组件**。

## 使用组件

> [!tip]
>
> 我们会在接下来的指引中使用 SFC
> 语法，无论你是否使用构建步骤，组件相关的概念都是相同的。[示例](https://cn.vuejs.org/examples/)一节中展示了两种场景中的组件使用情况。

**要使用一个子组件，我们需要在父组件中导入它**。假设我们把计数器组件放在了一个叫做 `ButtonCounter.vue` 的文件中，这个组件将
**会以默认导出的形式被暴露给外部**。

```vue

<script setup>
  import ButtonCounter from './ButtonCounter.vue'
</script>

<template>
  <h1>Here is a child component!</h1>
  <ButtonCounter/>
</template>
```

**通过 `<script setup>`，导入的组件都在模板中直接可用**。

当然，你**也可以全局地注册一个组件，使得它在当前应用中的任何组件上都可以使用，而不需要额外再导入**
。关于组件的全局注册和局部注册两种方式的利弊，我们放在了[组件注册](../深入组件/注册.md)这一章节中专门讨论。

**组件可以被重用任意多次**：

```html
<h1>Here is a child component!</h1>
<ButtonCounter/>
<ButtonCounter/>
<ButtonCounter/>
```

[▶ 在演练场中尝试一下](https://play.vuejs.org/#eNqVUstOwzAQ/JXFF0CgBAQnCIiHKgEHQMAFyZeQblu3iR3Z61IU5d9ZO21p1aoSh0T2zOzLO424retk6lFciMwVVtUEDsnX11KrqjaW4M4TGX1vvCa0MLCmgv0kXUNDgv1LqaXO0i4Jh/OFsKrLnJBvANno9PoBLULOX5XrHyhGquxDYbiORk1uL0tZE7XrRdN/gVm6UlccC3KF0QM1TMbOaJ6zCXFShLqqRPtSkzLaSXEBkQlcXpbm+yliZD0eL/BihMVkCz52s4BJ8WrRoZ2iFEuOcjtE6uje+zPO+LwkK9P3Jat3kG/oTOlDj53szus+t72ii90+xm0pPfxwvRmhdouhQqNB2Ua9FLyr+x2j/7V7lpzHOKlbfsWNhW9xDMDcM43FQTv3SvBGcAPwprUj/nMKuAKWHJwcsmt2eeYrVoWbolTF5CosjYOPjqSINMCn8cDcBPtQITTNPHvbAqkKXdKpsrTLs2GO9hdvoQOu)

你会注意到，每当点击这些按钮时，**每一个组件都维护着自己的状态**，是不同的 `count`。这是因为**每当你使用一个组件，就创建了一个新的实例
**。

**在<u>单文件组件</u>中，推荐为子组件使用 `PascalCase` 的标签名，以此来和原生的 HTML 元素作区分**。虽然**原生 HTML
标签名是不区分大小写**的，但 **Vue 单文件组件是可以在编译中区分大小写**的。我们也**可以使用 `/>` 来关闭一个标签**。

如果你是**直接在 DOM 中书写模板** (例如原生 `<template>` 元素的内容)，**模板的编译需要遵从浏览器中 HTML 的解析行为**
。在这种情况下，你应该**需要使用 `kebab-case` 形式并显式地关闭这些组件的标签**。

```html
<!-- 如果是在 DOM 中书写该模板 -->
<button-counter></button-counter>
<button-counter></button-counter>
<button-counter></button-counter>
```

请看 [DOM 内模板解析注意事项](#in-dom-template-parsing-caveats)了解更多细节。

## 传递 props

如果我们正在构建一个博客，我们可能需要一个表示博客文章的组件。我们希望所有的博客文章分享相同的视觉布局，但有不同的内容。要实现这样的效果自然必须
**向组件中传递数据**，例如每篇文章标题和内容，这就会使用到 props。

**Props 是一种特别的 attributes，你可以在组件上声明注册**。要传递给博客文章组件一个标题，我们**必须在组件的 props 列表上声明它
**。这里要用到 **[`defineProps`](https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits) 宏**：

```vue
<!-- BlogPost.vue -->
<script setup>
  defineProps(['title'])
</script>

<template>
  <h4>{{ title }}</h4>
</template>
```

> [!tip]
>
> 1. **`defineProps` 是一个仅 `<script setup>` 中可用的编译宏命令，并不需要显式地导入**。
>
> 2. **声明的 props 会自动暴露给模板**。
>
> 3. **`defineProps` 会返回一个对象，其中包含了可以传递给组件的所有 props**：
     >
     >    ```js
>    const props = defineProps(['title'])
>    console.log(props.title)
>    ```

如果你**没有使用 `<script setup>`，props 必须以 `props` 选项的方式声明**，**props 对象会作为 `setup()` 函数的第一个参数被传入
**：

```js
export default {
  props: ['title'],
  setup(props) {
    console.log(props.title)
  }
}
```

一个组件可以有任意多的 props，默认情况下，所有 prop 都接受任意类型的值。

当一个 prop 被注册后，可以像这样以自定义 attribute 的形式传递数据给它：

```html

<BlogPost title="My journey with Vue"/>
<BlogPost title="Blogging with Vue"/>
<BlogPost title="Why Vue is so fun"/>
```

在实际应用中，我们可能在父组件中会有如下的一个博客文章数组：

```js
const posts = ref([
  {id: 1, title: 'My journey with Vue'},
  {id: 2, title: 'Blogging with Vue'},
  {id: 3, title: 'Why Vue is so fun'}
])
```

这种情况下，我们可以使用 `v-for` 来渲染它们：

```html

<BlogPost
  v-for="post in posts"
  :key="post.id"
  :title="post.title"
/>
```

[▶ 在演练场中尝试一下](https://play.vuejs.org/#eNqFUstOwzAQ/JWVLwGpJOJxCgEJEAeQgAoQHDCHqtmkLolt2U5pFeXfWTt9CZVyy85M1jO727IrreNZgyxlmR0boR1YdI2+5FLUWhkHLRgsoIPCqBoikkZr6rpS5VBZt+TiZAX4jtE5l1yOlSReE2bhwnc6+OASqKnIUzgegBOuwhSihwVMVWMkLuBbuAm8UQPoBhvtyUbrXymFLP9Qnm6U75OF50FYsAqKRpKSy89DLrOkT0s5qXBY62rkkCqAbB1rdlQoc8GZtw9C9jE4g/QLF0s4FrkHwoMrKBSEJtQuS7Z6swFzliZSiDKeWiVp6K1/kbOxqrWo0DxpJ2hinKUQGM+Nqkp93wfMmQZD0vDPBMdfO/CpnXuMs6FBi2ZGVtacG5kSXU/fvjzinL7XZK3yxhvfQz6jVVXjPfay60bmZHtLF9zehfugFb3a27lDaVehvFGv7PfFGd3JzZ7oG7un8Vn4j8uOprh9ZzsuN8dCSBwape3BRxTWEf239MnZZdv2hwNdlyVU/95e9wMmKhA2)

留意我们是如何**使用 `v-bind` 来传递动态 prop 值**的。当事先不知道要渲染的确切内容时，这一点特别有用。

以上就是目前你需要了解的关于 props 的全部了。如果你看完本章节后还想知道更多细节，我们推荐你深入阅读关于 props
的[完整指引](../深入组件/Props.md)。

## 监听事件

让我们继续关注我们的 `<BlogPost>` 组件。我们会发现有时候它**需要与父组件进行交互**
。例如，要在此处实现无障碍访问的需求，将博客文章的文字能够放大，而页面的其余部分仍使用默认字号。

在父组件中，我们可以添加一个 `postFontSize` ref 来实现这个效果：

```js
const posts = ref([
  /* ... */
])

const postFontSize = ref(1)
```

在模板中用它来控制所有博客文章的字体大小：

```html

<div :style="{ fontSize: postFontSize + 'em' }">
  <BlogPost
    v-for="post in posts"
    :key="post.id"
    :title="post.title"
  />
</div>
```

然后，给 `<BlogPost>` 组件添加一个按钮：

```vue
<!-- BlogPost.vue, 省略了 <script> -->
<template>
  <div class="blog-post">
    <h4>{{ title }}</h4>
    <button>Enlarge text</button>
  </div>
</template>
```

这个按钮目前还没有做任何事情，我们想要点击这个按钮来告诉父组件它应该放大所有博客文章的文字。要解决这个问题，*
*组件实例提供了一个自定义事件系统**。**父组件可以通过 `v-on` 或 `@` 来<u>选择性</u>地监听子组件上抛的事件**，就像监听原生
DOM 事件那样：

```html

<BlogPost
  ...
  @enlarge-text="postFontSize += 0.1"
/>
```

子组件可以通过调用内置的 [**`$emit`** 方法](https://cn.vuejs.org/api/component-instance.html#emit)，**通过传入事件名称来抛出一个事件
**：

```vue
<!-- BlogPost.vue, 省略了 <script> -->
<template>
  <div class="blog-post">
    <h4>{{ title }}</h4>
    <button @click="$emit('enlarge-text')">Enlarge text</button>
  </div>
</template>
```

因为有了 `@enlarge-text="postFontSize += 0.1"` 的监听，父组件会接收这一事件，从而更新 `postFontSize` 的值。

[▶ 在演练场中尝试一下](https://play.vuejs.org/#eNp9U11v0zAU/StXFlI60SWU7Smk0xgqEkhAxRA8zDyU5KZ1m9iR7XQtUf77rp1+pNrWt/icc6/PvT5p2MeqCtc1spglJtWismDQ1tUNl6KslLbQgMYcWsi1KiEgaXCg7go1nypjd1wY7QHXMfjAJZepksRXhBkYu06DBy6BmooshtEQrLAFxhB828JS1VriFh6FXcBvagDt8Kh9f9S6W+ZCzl9RXh2VfxZbx4MwYBTktSQll38vTp19VtLei/+4MzgiOom6ZdAa6GCxrIqZRToBJJlYQ2zstsAxZw3ku+r4tNdbCLB01zFfRXWHba0vc6Wp1ulByG47nEG8wu0ODkXmAD/HHvIHQm9RFjM9x0uLG7sjj9eO4V04IlXUmY3ILX0lUW8GNmTW0Pi5mIdLoyS9fePEnKWqrESB+kdlBa2Hsxg847hZUajHrx6zuka/cF+zwHT1Ar40G4dxNtVoUK/J+oGzzr/t6Mn9d5qjR5Yqq92gZ8ifaFRRO4+d7K6WGdnu6bzbLz6mlJRfZrKxKM1+KGfUKbvYcEZx/XRm9KPdq/Da13HZ0hb7cX/hB8owFxKnWlVm8BD45wtc9jp8Ugrr8P5revpc9hbXN03TxRvaNono7PF/tbVKwm1aiHRFmXiD1H1w2vuCojjpAHBAEnVVz+LRPgG5jV9M)

我们可以**通过 [`defineEmits`](https://cn.vuejs.org/api/sfc-script-setup.html#defineprops-defineemits) 宏来声明需要抛出的事件
**：

```vue
<!-- BlogPost.vue -->
<script setup>
  defineProps(['title'])
  defineEmits(['enlarge-text'])
</script>
```

这**声明了一个组件可能触发的所有事件，还可以对事件的参数进行[验证](../深入组件/事件.md#validate-emitted-events)**
。同时，这还可以让 Vue **避免将它们作为原生事件监听器隐式地应用于子组件的根元素**。

和 `defineProps` 类似，**`defineEmits` 仅可用于 `<script setup>` 之中，并且不需要导入，它返回一个等同于 `$emit`
方法的 `emit` 函数**，**它可以被用于在组件的 `<script setup>` 中抛出事件**，因为此处无法直接访问 `$emit`：

```vue

<script setup>
  const emit = defineEmits(['enlarge-text'])

  emit('enlarge-text')
</script>
```

如果你**没有使用 `<script setup>`，你可以通过 `emits` 选项定义组件会抛出的事件**。你**可以从 `setup()` 函数的第二个参数，即
setup 上下文对象上访问到 `emit` 函数**：

```js
export default {
  emits: ['enlarge-text'],
  setup(props, ctx) {
    ctx.emit('enlarge-text')
  }
}
```

以上就是目前你需要了解的关于组件自定义事件的所有知识了。如果你看完本章节后还想知道更多细节，请深入阅读[组件事件](../深入组件/事件.md)
章节。

## 通过插槽来分配内容

一些情况下我们会希望能和 HTML 元素一样**向组件中传递内容**：

```html

<AlertBox>
  Something bad happened.
</AlertBox>
```

我们期望能渲染成这样：

:::danger This is an Error for Demo Purposes
Something bad happened.
:::

这可以通过 Vue 的自定义 `<slot>` 元素来实现：

```vue

<template>
  <div class="alert-box">
    <strong>This is an Error for Demo Purposes</strong>
    <slot/>
  </div>
</template>

<style scoped>
  .alert-box {
    /* ... */
  }
</style>
```

如上所示，我们**使用 `<slot>` 作为一个占位符，父组件传递进来的内容就会渲染在这里**。

[▶ 在演练场中尝试一下](https://play.vuejs.org/#eNp9Ustu2zAQ/JUte8gllvoIjEJVDSSFD+2hLZoedZHEtayE4hIk5SoI/O9ZUo8YSWDoop2ZXc3O6lFcG5McehSZyF1tW+PBoe/NptBtZ8h6uFZo/Q0NsLPUwUWSzkBou/ha6DwdG7mFC4+dUaVHrgDyWRsrgFvq0O9b3UBVStiXxqCWSVQuY1mapydTxKXwria9a5vkzpFmp4+hoxA1dablrt/Gt6RdITKITOBKpej/z4h52+PljNd7rO/fwO/cELBC/LHo0B6wEAvnS9ugH+nt7S8c+H0hO5K9YvUZ8i86Un3wOMpuei3Z9okuuv0R8+Zw/rnt4FG7ealgNCiPUV8Izv37mdWf7X5OrmJfoY+c4undXp373BFle4Balc59C055yKoiTmu6ae68Jd1sttaSfcdzxnIiKwvpIlTkpypPeejLS3Pp/INC4HMblIwky+fG9WpSZDN4v16v+ccDqMhKZOCjGYAzbiVYlCfMypay7V0GV2aIsCml5IQz+PRhQqqyvm8s8UlW8/Tdl/Awy8FxoHrcKDgo/KQJn4lpB03YmW1vxPEJ7DIazg==)

以上就是目前你需要了解的关于插槽的所有知识了。如果你看完本章节后还想知道更多细节，请深入阅读[组件插槽](../深入组件/插槽.md)
章节。

## 动态组件

有些场景会需要在两个组件间来回切换，比如 Tab 界面：

[▶ 在演练场中查看示例](https://play.vuejs.org/#eNqtVd1O2zAUfpWjcNEiNSkMtIusRWMT0raLDW3cLWhyHac1dezIdkpR1XffsZ2kKVDUCxS18vn/zmf7eBNdV1WyqlmURhNDNa8sGGbr6iqTvKyUtrABzYoRPBJLFzdFwaiFLRRalTDAuEHn902VrNEnYye4tINPnf1WGWs6By8987jWdMFXuySN3HplkippLNBaaybtHZnB1GEbDly1wenOw5KZQdsmk+BhjdzCV/SrJm8mty6k19hweArTqxDnMinBEqHmQ5fv765ssiKiZvdYcIu/yTjwhoyhYFlZCWIZSgCTnK+ACmLMNItyVqos8nq0zGprlYRVXCiNxuG/kUN9Clx69FkE6ZI9oQUlFNokKMUh1Hm02g0QarGjdI+b6dSlgm0WhZoAn6ngdIkBexT6Cg0ugM0mRCE3Hug4lGtxU4V7JTEWUt4A6lNzv48V807GXUjgZIyk4Goy7lGForFPwi0Tx1PYgkJJGxek5OIpBUOkiQ3TvMCjADBTOmc6hfNqDbhPPIcTxljPFGuS89qk8KFae3VF8pzLOSrOMOYC/7y6JHrOZWxVhclY2dfNFHZepnDZ+tZYHzEIPCopSOzJa9WK6UKox3idAqmtQqU/WMlus0I/HYKPCOC8TdrARQCxYIXtcF+8tGs+Xxxy2KOCUupNuDFGoalSXFqmgzuhy7lWtcxTOCnO3Pda0zGm6+t97U79vMF04VgIbe4VYGfueyUiCUf2qJDG6XCfHbMNqxiJ17I5UdEosgavc8HnyYNREkedz4fXAE8mF0z/qizH655FaajkbETglv7wOqvrMEJ8zILR5Sv6B7N2uiy61QyPCY6XqLNZpJDZYL7585Otcd0ZS5XXAr3fMP5m2G/tMAa3L0gUwu75ebTf/RhFHu7MzdoyadqmHFDnufX+WYQD9esbre/gXiSXPg4ZRRbbof7irTh2BPYnjX8uutFwcDJg2e6peJe64Rk6qnDv/XmX0u37dkTx7X/dWZTN)

上面的例子是**通过 Vue 的 `<component>` 元素和特殊的 `is` attribute 实现**的：

```html
<!-- currentTab 改变时组件也改变 -->
<component :is="tabs[currentTab]"></component>
```

在上面的例子中，被传给 `:is` 的值可以是以下几种：

- 被注册的组件名
- 导入的组件对象

你也可以使用 `is` attribute 来创建一般的 HTML 元素。

**当使用 `<component :is="...">` 来在多个组件间作切换时，被切换掉的组件会被<u>卸载</u>**。我们*
*可以通过 [`<KeepAlive>` 组件](https://cn.vuejs.org/guide/built-ins/keep-alive.html)强制被切换掉的组件仍然保持“存活”的状态
**。

## DOM 内模板解析注意事项 {#in-dom-template-parsing-caveats}

如果你想**在 DOM 中直接书写 Vue 模板，Vue 则必须从 DOM 中获取模板字符串**。由于浏览器的原生 HTML 解析行为限制，有一些需要注意的事项。

> [!TIP]
>
> **请注意下面讨论只适用于直接在 DOM 中编写模板（通过 el 选项指定的挂载元素）的情况**。如果你使用来自以下来源的字符串模板，就不需要顾虑这些限制了：
>
> - 单文件组件
> - 内联模板字符串 (例如 `template: '...'`)
> - `<script type="text/x-template">`

### 大小写区分

**HTML 标签和属性名称是不分大小写的**，所以**浏览器会把任何大写的字符解释为小写**
。这意味着<strong style="font-size:18px;color:#eebe77;">当你使用 DOM 内的模板时，无论是 PascalCase 形式的组件名称、camelCase
形式的 prop 名称还是 v-on 的事件名称，都需要转换为相应等价的 kebab-case (短横线连字符) 形式</strong>：

```js
// JavaScript 中的 camelCase
const BlogPost = {
  props: ['postTitle'],
  emits: ['updatePost'],
  template: `
    <h3>{{ postTitle }}</h3>
  `
}
```

```html
<!-- HTML 中的 kebab-case -->
<blog-post post-title="hello!" @update-post="onUpdatePost"></blog-post>
```

### 闭合标签

我们在上面的例子中已经使用过了闭合标签 (self-closing tag)：

```html

<MyComponent/>
```

这是因为 **Vue 的模板解析器支持任意标签使用 `/>` 作为标签关闭的标志**。

然而<strong style="font-size:18px;color:#eebe77;">在 DOM 内模板中，我们必须<u>显式</u>地写出关闭标签</strong>：

```html

<my-component></my-component>
```

这是由于 HTML 只允许[一小部分特殊的元素](https://html.spec.whatwg.org/multipage/syntax.html#void-elements)省略其关闭标签，最常见的就是
`<input>` 和 `<img>`。对于其他的元素来说，**如果你省略了关闭标签，原生的 HTML 解析器会认为开启的标签永远没有结束**
，用下面这个代码片段举例来说：

```html

<my-component/> <!-- 我们想要在这里关闭标签... -->
<span>hello</span>
```

将被解析为：

```html

<my-component>
  <span>hello</span>
</my-component> <!-- 但浏览器会在这里关闭标签 -->
```

### 元素位置限制

某些 HTML 元素对于放在其中的元素类型有限制，例如 `<ul>`，`<ol>`，`<table>` 和 `<select>`，相应的，**某些元素仅在放置于特定元素中时才会显示
**，例如 `<li>`，`<tr>` 和 `<option>`。

这将导致在使用带有此类限制元素的组件时出现问题。例如：

```html

<table>
  <blog-post-row></blog-post-row>
</table>
```

自定义的组件 `<blog-post-row>` 将作为无效的内容被忽略，因而在最终呈现的输出中造成错误。我们可以使用特殊的 [
`is` attribute](https://cn.vuejs.org/api/built-in-special-attributes.html#is) 作为一种解决方案：

```html

<table>
  <tr is="vue:blog-post-row"></tr>
</table>
```

> [!tip]
>
> **当使用在原生 HTML 元素上时，`is` 的值必须加上前缀 `vue:` 才可以被解析为一个 Vue 组件**
> 。这一点是必要的，为了避免和原生的[自定义内置元素](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements-customized-builtin-example)
> 相混淆。

以上就是你需要了解的关于 DOM 内模板解析的所有注意事项，同时也是 Vue *基础*部分的所有内容。祝贺你！虽然还有很多需要学习的，但你可以先暂停一下，去用
Vue 做一些有趣的东西，或者研究一些[示例](https://cn.vuejs.org/examples/)。

完成了本页的阅读后，回顾一下你刚才所学到的知识，如果还想知道更多细节，我们推荐你继续阅读关于组件的完整指引。
