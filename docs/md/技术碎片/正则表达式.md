# 正则表达式

## 简介

正则表达式（Regular Expression）是一种***文本模式***，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“***元字符***”），可以用来描述和匹配字符串的特定模式。

正则表达式是一种用于模式匹配和搜索文件的工具；

正则表达式提供了一种灵活且强大的方式来<u>查找</u>、<u>替换</u>、<u>验证</u>和<u>提取</u>文本数据；

正则表达式可以应用于各种编程语言和文本处理工具中，如 JavaScript、Python、Java、Perl 等。

## 创建正则

可以使用以下两种方法构建一个正则表达式。

### 字面量创建👍

使用一个正则表达式字面量，其由包含在斜杠 `//` 之间的模式组成，如下所示：

```js
let regex = /ab+c/;
```

脚本加载后，正则表达式字面量就会被编译。当正则表达式保持不变时，使用此方法可获得更好的性能。

这种方式不能在其中使用变量，虽然可以使用 `eval` 转换为 js 语法来实现将变量解析到正则中，如下所示，这种方式比较麻烦，所以有变量时建议使用下面的[对象创建](#对象创建)方式。

```js
let site = "xiaorang.com";
let regex = "a";
console.log(eval(`/${regex}/`).test(site)); // true
```

### 对象创建

调用[`RegExp`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)对象的构造函数，如下所示：

```js
let regex = new RegExp("ab+c");
```

在脚本运行过程中，用构造函数创建的正则表达式会被编译。如果正则表达式将会改变，或者它将会从用户输入等来源中动态产生，就需要使用构造函数来创建正则表达式。

举个栗子（1）：根据用户输入高亮显示内容，支持用户输入正则表达式。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div class="content">docs.xiaorang.fun</div>
  </body>
  <script>
    const search = prompt("请输入要搜索的内容，支持正则表达式");
    const regex = new RegExp(search, "g");
    let content = document.querySelector(".content");
    content.innerHTML = content.innerHTML.replace(
      regex,
      (value) => `<span style="color:red;">${value}</span>`
    );
  </script>
</html>
```

举个栗子（2）：通过对象创建正则提取标签。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <h1>xiaorang.fun</h1>
    <h1>docs.xiaorang.fun</h1>
  </body>
  <script>
    function element(tag) {
      const body = document.body.innerHTML;
      let regex = new RegExp("<(" + tag + ")>.+</\\1>", "g");
      return body.match(regex);
    }
    console.table(element("h1"));
  </script>
</html>
```

控制输出结果如下所示：<br />![image-20240202174334582](https://cdn.jsdelivr.net/gh/xihuanxiaorang/img/202402021744911.png)

## 元字符

### 任意字符（`.`）

`.` 字符默认匹配除换行符之外的任意单个字符。如果<span style="background-color: #95d475">**单行标志`s`**</span>被设置为 true，那么它也会匹配换行符。

举个栗子：正则表达式: `/.ar/g`，表示匹配一个任意字符后紧跟着a和r的字符串。输入的字符串：“The car parked in the garage” => “The <span style="background-color: #c3dcfc">car</span> <span style="background-color: #c3dcfc">par</span>ked in the <span style="background-color: #c3dcfc">gar</span>age”

### 转义字符（`\`）

如果要把特殊字符作为常规字符来使用，则需要对其进行转义，只需在它前面加个反斜杠 `\` 即可。

常见的需要转义的字符：`[ ] ( ) { } . * + ? ^ $ \`。

假如有这样的场景，如果想通过正则表达式查找斜杠符号 `/`，虽然它并不是一个特殊字符，但是在字面量正则表达式中有特殊的含义。如果写成 `///` 的话则会造成解析错误，所以要使用转义语法 `/\//` 来匹配。

```js
const url = "https://docs.xiaorang.fun";
console.log(/https?:\/\//.test(url)); // true
```

使用 `RegExp` 对象创建正则时在转义上会有些许区别，下面为对象与字面量创建正则时的区别：

```js
let price = 12.23;
// .字符在正则表达式中表示除换行符之外的任何字符，如果想表示普通的字符.，则需要使用\.才能转义成普通的字符.
console.log(/\d+\.\d+/.test(price));
// 在字符串中 \d 与 d 的含义是一样的，所以在使用RegExp时\d会被视为d，因此需要在前面再额外多加一个\ => \\d
console.log("\d" === "d");
let regex = new RegExp("\\d+\\.\\d+");
console.log(regex.test(price));
```

> [!TIP]
>
> 在使用 `RegExp` 对象创建正则时，如果自己不确定的话，可以先使用 `console.log` 把表达式打印出来，如果结果和字面量定义的一样则表示对了！

举个栗子（1）：网址检测中转义字符的使用。

```js
let url = "https://docs.xiaorang.fun";
console.log(/https?:\/\/\w+\.\w+\.\w+/.test(url)); // true
```

举个栗子（2）：匹配所有以 `.js` 或者 `.jsx` 结尾的文件名。

```js
const fileNames = ["abc.js", "cba.java", "nba.html", "mba.js", "aaa.jsx"];
const newNames = fileNames.filter(item => /\.jsx?$/.test(item));
console.log(newNames); // ['abc.js', 'mba.js', 'aaa.jsx']
```

### 量词（`*`、`+`、`?`、`{n,m}`）

> [!IMPORTANT]
>
> 默认情况下，像 `*`、`+`、`?`、`{n,m}` 这样的量词是**贪婪的**，这意味着**它们试图尽可能地通过提供的文本扩展匹配，通俗点说，就是匹配尽可能多的字符串**。
>
> 如果在以上量词的后面加上 `?` 字符的话，则会使被修饰的量词变成**非贪婪的**，意味着**它一旦找到匹配的就会停止**。
>
> 举个栗子：给定一个字符串 “`some <foo> <bar> new </bar> </foo> thing`”，从下面的结果就可以看出在量词后面加上`?`的字符所产生的影响以及与不加时的区别。
>
> - `/<.*>/g` 将会匹配 “`<foo> <bar> new </bar> </foo>`”
> - `/<.*?>/g` 将会匹配 “`<foo>`”

| 字符    | 描述                                                         | 例子                                                         |
| ------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `*`     | 匹配`>=0`个重复在`*`号之前的字符，等价于`{0,}`。`.`字符与`*`字符搭配，即`.*`=>可以匹配所有的字符。 | 例如，正则表达式 ：`/a*/g`，表示匹配以`a`字符开头后面紧跟着0个或无数个字符的字符串。正则表达式：`/[a-z]*/g` 表示匹配所有以小写字母组成的字符串 => “T<span style="background-color: #c3dcfc">he</span> <span style="background-color: #c3dcfc">car</span> <span style="background-color: #c3dcfc">parked</span> <span style="background-color: #c3dcfc">in</span> <span style="background-color: #c3dcfc">the</span> <span style="background-color: #c3dcfc">garage</span>.” |
| `+`     | 匹配`>=1`个重复在`+`号之前的字符，等价于`{1,}`。             | 例如，正则表达式：`/c.+t/g`，表示匹配以首字母`c`开头以字母`t`结尾，中间至少夹着一个字符的字符串 => “The fat <span style="background-color: #c3dcfc">cat sat on the mat</span>.” |
| `?`     | 标记`?`号之前的字符为可选，即可出现1次或0次，等价于`{0,1}`。 | 例如，正则表达式：`/[T]?he/g`，表示匹配字符串`The`或者`he` => “<span style="background-color: #c3dcfc">The</span> car is parked in t<span style="background-color: #c3dcfc">he</span> garage.” |
| `{n,m}` | 匹配num（其中 `n <= num <= m`）个大括号之前的字符或字符集，即至少n次，至多m次。 | 例如，正则表达式：`/[0-9]{2,3}/g`，表示匹配2位数或3位数的数字 => “The number was 9.<span style="background-color: #c3dcfc">999</span>7 but we rounded it off to <span style="background-color: #c3dcfc">10</span>.0.” |
| `{n,}`  | 匹配num（其中 `n <= num`）个大括号之前的字符或字符集，即至少n次。 | 例如，正则表达式：`/[0-9]{2,}/g`，表示匹配至少2位数的数字 => “The number was 9.<span style="background-color: #c3dcfc">9997</span> but we rounded it off to <span style="background-color: #c3dcfc">10</span>.0.” |
| `{n}`   | 匹配n个大括号之前的字符或字符集，即固定的n次。               | 例如，正则表达式：`/[0-9]{3}/g`，表示匹配3位数的数字 => “The number was 9.<span style="background-color: #c3dcfc">999</span>7 but we rounded it off to 10.0.” |

### 字符集/原子表（`[]`）

`[]` 称之为字符集，匹配方括号中的任意一个字符，包括转义字符 `\`。

> [!NOTE]
>
> 在方括号中的字符不关心顺序。
>
> 在方括号中可以使用连字符来指定一个字符范围，比如 `[0-9a-zA-Z]` 可以匹配任意一个字母或者数字。
>
> 对于 `.` 和 `*` 这样的特殊符号在一个字符集中没有特殊的意义，它们不必进行转义，不过转义的话也是起作用的。

举个栗子（1）：正则表达式：`/ar[.]/g`，输入的字符串：“A garage is a good place to park a car.” => “A garage is a good place to park a c<span style="background-color: #c3dcfc">ar.</span>”

举个栗子（2）：正则表达式：`/[a-z.]+/g` 或 `/[\w.]+/`，输入的字符串：“test.i.ng” => “<span style="background-color: #c3dcfc">test.i.ng</span>”

#### 否定字符集（`[^]`）

`[^]` 称之为否定字符集，它用于匹配任何一个没有包含在当前方括号中的字符。

举个栗子（1）：正则表达式：`/[^c]ar/g`，用于匹配任意一个除字符`c`之外后面跟着`ar`的字符串，输入的字符串：“The car parked in the garage.” => “The car <span style="background-color: #c3dcfc">par</span>ked in the <span style="background-color: #c3dcfc">gar</span>age.”

举个栗子（2）：正则表达式：`/[^abc]/g` 或 `/[^a-c]/g`，输入的字符串：“chop” => “c<span style="background-color: #a0cfff">h</span><span style="background-color: #79bbff">o</span><span style="background-color: #a0cfff">p</span>”

#### 预定义字符集

正则表达式提供一些常用的预定义字符集。如下所示:

| 字符 | 描述                                                         | 例子                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `\d` | 匹配任意一个数字字符，等价于 `[0-9]`。                       | 例如，正则表达式：`/\d/g`=> “B<span style="background-color: #c3dcfc">2</span> is the suite number.” <br />例如，正则表达式 `/\d{2,3}/g` 用于匹配 2~3 位的数字字符 => “The number was 9.<span style="background-color: #c3dcfc">999</span>7 but we rounded it off to <span style="background-color: #c3dcfc">10</span>.0.” |
| `\D` | 与 `\d` 的意思刚好相反，匹配任意一个非数字字符，等价于 `[^0-9]` 或 `[^\d]`。 | 例如，正则表达式：`/\D+/g` => “<span style="background-color: #c3dcfc">one: </span>1<span style="background-color: #c3dcfc">, two: </span>2” |
| `\w` | 匹配任意一个字母、数字或下划线字符，等价于 `[A-Za-z0-9_]`。  | 例如，正则表达式：`/\w+/g` => “<span style="background-color: #c3dcfc">any</span> <span style="background-color: #c3dcfc">word</span> <span style="background-color: #c3dcfc">character</span>” |
| `\W` | 与 `\w` 的意思刚好相反，匹配任意一个除字母、数字和下划线之外的字符，等价于 `[^A-Za-z0-9_]` 或 `[^\w]`。 | 例如，正则表达式：`/\W+/g` => “not<span style="background-color: #c3dcfc">.</span>a<span style="background-color: #c3dcfc">@</span>word<span style="background-color: #c3dcfc">%</span>character” |
| `\s` | 匹配任意一个空白字符，包括空格、制表符、换页符和换行符，等价于 `[ \t\f\n\r\v]`。 | 例如，正则表达式：`/\s+/g`，输入字符串：”any whitespace character.“ => “any<span style="background-color: #c3dcfc">`_`</span>whitespace<span style="background-color: #c3dcfc">`_`</span>character.”（此处的下划线仅仅是为了占位，不然背景色显示不出来） |
| `\S` | 匹配任意一个非空白字符，等价于 `[^ \t\f\n\r\v]` 或 `[^\s]`。 | 例如，正则表达式：`/\S+/g` => “<span style="background-color: #c3dcfc">any</span> <span style="background-color: #c3dcfc">non-whitespace.</span>” |

### 锚点（`^`与`$`）

| 字符 | 描述                                                         | 例子                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `^`  | 用来检查匹配的字符串是否在所输入字符串的**开头**。如果<span style="background-color: #95d475">**多行标志`m`**</span>被设置为 true，即设置了 RegExp 对象的 Multiline 属性的话，那么也会匹配换行符后紧跟的位置。 | 例如，`/^(T\|t)he/g` 用于匹配以 The 或 the 开头的字符串。<br />`/^(T\|t)he/g` => <span style="background-color: #c3dcfc">The</span> car is parked in <span style="background-color: #f89898">the</span> garage.<br />此处，为什么没有匹配小写的 the 呢？那是因为它并没有出现在字符串**开头**的位置。 |
| `$`  | 用来检查匹配的字符串是否在所输入字符串的**结尾**。如果<span style="background-color: #95d475">**多行标志`m`**</span>被设置为 true，即设置了 RegExp 对象的 Multiline 属性的话，那么也会匹配换行符之前的位置。 | 例如，`/(at\.)$/g` 用于匹配以 at. 结尾的字符串。<br />`/(at\.)$/g` => The fat <span style="background-color: #f89898">cat.</span> <span style="background-color: #f89898">sat.</span> on the <span style="background-color: #c3dcfc">mat.</span><br />此处，为什么没有匹配 cat. 和 sat. 中的 at. 呢？那是因为这两项并没有出现在字符串**结尾**的位置。 |

举个栗子：检测用户名长度为 3~6 位，且只能为字母。如果不同时使用 `^` 和 `$` 的话则无法得到正确答案，输入的字符串必须是 3~6 位且全部都为字母！

```html                      
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <input type="text" name="username" />
    <script>
      document.body
        .querySelector(`[name="username"]`)
        .addEventListener("keyup", function () {
          console.log(/^[a-zA-Z]{3,6}$/.test(this.value));
        });
    </script>
  </body>
</html>
```

### 边界（`\b`与`\B`）

`\b` 表示**单词边界**。

`\B` 表示**非单词边界**，应理解为<span style="background-color: #c3dcfc">**（非单词）边界**</span>，而不是<span style="background-color: #f89898">非（单词边界）</span>，它仍然匹配的是边界。

> [!IMPORTANT]
>
> 将正则中的位置分为 **字符的占位** 和 **字符的间隙**。
>
> **字符的占位是显式的位置**。以 I'm iron man 为例，肉眼可见的**字母**、**符号**、**空格**都是可以占位的字符，也就是可以用下标获取到字符的位置。
>
> **字符的间隙是隐式的位置**，即**显式位置之间的位置**。比如说 `I` 和 `'` 之间的位置，字符串开头和 `I` 之间的位置等等。
>
> 其中**边界**指的就是**占位的字符左右的间隙位置**。
>
> - **单词边界**匹配的是这样的间隙位置：**左右两边占位的字符至少有一个不是`\w`**。如下所示：
>   - 正则表达式：`/\b/g`，输入的字符串：`0az`；用 “.” 替换的话 => `.0az.`，只有首位位置匹配；
>   - 正则表达式：`/\b/g`，输入的字符串：`a+a`；用 “.” 替换的话 => `.a.+.a.`，因为 `+` 号不属于 `\w`，所以 `+` 号的左右间隙都可以被匹配；
>   - 正则表达式：`/\b/g`，输入的字符串：`a a`；用 “.” 替换的话 => `.a. .a.`，与上一个案例的情形类似，因为空格也不属于 `\w`，所以空格的左右间隙也都可以被匹配；
> - **非单词边界**与单词边界相反，匹配的是这样的间隙位置：**左右两边占位的字符必须都是`\w`**。
>   - 正则表达式：`/\B/g`，输入的字符串：`0aZ_`；用 “.” 替换的话 => `0.a.Z._`；
>   - 正则表达式：`/\B/g`，输入的字符串：`a+a`；用 “.” 替换的话 => `a+a`，在这个例子找不到这样的间隙位置，原样输出；
>   - 正则表达式：`/\B/g`，输入的字符串：`a a`；用 “.” 替换的话 => `a a`，同上一个案例一样，也找不到这样的间隙位置，原样输出；

> [!NOTE]
>
> `/\w\b\w/` 将不能匹配任何字符串，因为 `\b` 要求两边占位的字符至少有一个不是 `\w`，而现在两边占位的字符都是 `\w`，所以该正则表达式将不能匹配任何字符串！

举个栗子（1）：正则表达式：`/d\b/g`，输入的字符串：“word boundaries are odd” => “wor<span style="background-color: #c3dcfc">d</span> boundaries are od<span style="background-color: #c3dcfc">d</span>”

举个栗子（2）：正则表达式：`/r\B/g`，输入的字符串：“regex is really cool” => “regex is really cool” => “<span style="background-color: #c3dcfc">r</span>egex is <span style="background-color: #c3dcfc">r</span>eally cool”

### 选择分支（`|`）

`|` 这个符号代表选择修饰符，也就说左右两侧（需要各自看成是一个整体）只要有一个匹配即可，类似于“或”的逻辑。

举个栗子：检测电话是否是上海或北京的坐机。

```js
let tel = "010-12345678";
// 错误结果：匹配输出的结果为010，因为它将正则表达式中|右侧看成了一个整体，导致只有|左侧的010满足条件，所以输出010，但是这样的结果并不满足咱们的要求
console.log(tel.match(/010|020-\d{7,8}/)); // [!code error]
// 正确结果：|需要放在原子组中进行使用，这样|右侧的内容只有)以内的020
console.log(tel.match(/(010|020)-\d{7,8}/))
```

## 标志/修饰符

## 在线工具🔨

- [regex101: build, test, and debug regex](https://regex101.com/)，推荐👍👍👍
- [RegExr: Learn, Build, & Test RegEx](https://regexr.com/)
- [Regulex：JavaScript Regular Expression Visualizer](https://jex.im/regulex/)

## 参考资料🎁

- [正则表达式 - JavaScript | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_expressions)

- [learn-regex/README-cn.md at master · ziishaned/learn-regex](https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md)

- [Regex Learn - 逐步从零基础到高阶](https://regexlearn.com/zh-cn)