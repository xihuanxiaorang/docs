# 泛型

## 引言

Java 泛型是在 JDK 1.5 中引入的一项新特性，它<strong style="color:#ae3520;">允许编译器在编译时进行类型检查</strong>，从而在运行时避免了不必要的类型转换。使用泛型可以提高代码的安全性和可读性，同时减少运行时错误。

## What Is Generics?

Wiki:

> Support for the *generics*, or "containers–of–type–T" was added to the Java programming language in 2004 as part of J2SE 5.0. **In Java, generics are <strong style="color:#ae3520;">only checked at compile time</strong> for <strong style="color:#ae3520;">type correctness</strong>** - <span style="font-size:13px;color:#909399;">泛型只在编译时检查类型正确性</span>. The generic type information is then removed via a process called <strong style="color:#ae3520;">type erasure</strong> - <span style="font-size:13px;color:#909399;">在运行时通过类型擦除来擦除泛型信息</span>, to maintain compatibility with old JVM implementations, making it unavailable at runtime. For example, a `List<String>` is converted to the raw type List. The compiler inserts type casts to convert the elements to the String type when they are retrieved from the list, reducing performance compared to other implementations such as C++ templates.

GeeksforGeeks:

> **Generics** means <strong style="color:#ae3520;">parameterized types</strong> - <span style="font-size:13px;color:#909399;">泛型的本质是参数化类型，即所操作的数据类型被指定为一个参数</span>. The idea is to allow type (Integer, String, … etc., and user-defined types) to be a parameter to methods, classes, and interfaces. Using Generics, it is possible to create classes that work with different data types.

## Why Use Generics?

简而言之，在定义类、接口和方法时，泛型使类型(类和接口)能够成为参数。与方法声明中使用的形式参数非常相似，类型参数为你提供了一种方法，可以在不同的输入中重用相同的代码。区别在于形式参数的输入是值，而<strong style="color:#ae3520;">类型参数的输入是类型</strong>。

与非泛型代码相比，使用泛型的代码有很多好处:

- <strong style="color:#ae3520;">编译时更强的类型检查</strong> <span style="font-size:13px;color:#909399;">（Stronger type checks at compile time ➡️ **代码更健壮**）</span>

  Java 编译器对泛型代码应用强类型检查，如果代码违反类型安全，则会发出错误。修复编译时的错误比修复运行时的错误更加容易，后者可能很难找到。

- <strong style="color:#ae3520;">消除强制转换</strong> <span style="font-size:13px;color:#909399;">（Elimination of casts ➡️ **代码更简洁**）</span>

  以下没有泛型的代码段需要进行强制转换：

  ```java
  List list = new ArrayList();
  list.add("hello");
  String s = (String) list.get(0);
  ```

  当使用泛型重新编写后，代码不再需要进行强制转换：

  ```java
  List<String> list = new ArrayList<String>();
  list.add("hello");
  String s = list.get(0);   // no cast
  ```

- <strong style="color:#ae3520;">代码更灵活复用</strong>

## Generic Types<span style="font-size:13px;color:#909399;"> - 泛型类型</span>

<strong style="color:#ae3520;">A *generic type* is a generic class or interface that is parameterized over types.</strong> - <span style="font-size:13px;color:#909399;">泛型类型是指对类型进行参数化的泛型类或接口</span>

### 一个简单的 Box 类

```java
public class Box {
    private Object object;

    public void set(Object object) { this.object = object; }
    public Object get() { return object; }
}
```

由于它的方法接受或返回 `Object` ，因此你可以自由地传递任何你想要的内容，只要它不是基本类型之一。无法在编译时验证该类的使用方式，一部分代码可能会在盒子中放置 `Integer` 并期望从中获取 `Integer` 类型，而另一部分代码可能会错误地传入 `String`，从而导致运行时错误。

### Box 类的泛型版本 {#box-generic-class}

泛型类的定义格式如下：

`class name<T1, T2, ..., Tn> { /* ... */ }`

<strong style="color:#ae3520;">类型参数部分由尖括号 ( `<>` ) 分隔，位于类名称之后</strong>。它指定类型参数（也称为类型变量） `T1` 、 `T2` 、 ... 和 `Tn` 。

若要更新 `Box` 类以使用泛型，你可以通过将代码 `public class Box` 更改为 `public class Box<T>` 来创建泛型类型声明。这引入了类型参数 `T` ，它可以在类中的任何地方使用。

```java
/**
 * Generic version of the Box class.
 * @param <T> the type of the value being boxed
 */
public class Box<T> {
    // T stands for "Type"
    private T t;

    public void set(T t) { this.t = t; }
    public T get() { return t; }
}
```

正如你所看到的，所有出现的 `Object` 都被替换为 `T` 。类型参数可以是你指定的任何非基本类型：类、接口、数组，甚至是另外一个类型参数。

可以使用相同的技术来创建泛型接口。

### 类型参数命名约定

按照约定，<strong style="color:#ae3520;">类型参数名称是单个大写字母</strong>。如果没有此约定，就很难区分类型变量和普通类或接口名称。

最常用的类型参数名称有：

- E - Element (used extensively by the Java Collections Framework - <span style="font-size:13px;color:#909399;">被 Java 集合框架广泛使用</span>)
- K - Key
- N - Number
- T - Type
- V - Value
- S,U,V etc. - 2nd, 3rd, 4th types

### 调用和实例化泛型类型

要在代码中引用 `Box` 泛型类，必须执行泛型类型调用，将类型参数 `T` 替换为具体的值，如 `Integer`：

```java
Box<Integer> integerBox;
```

你可以将泛型类型调用视为与普通方法调用类似，但不是将参数传递给方法，而是将类型参数 *type argument* (在本例中为整数) 传递给 Box 类本身。

> [!note]
>
> <strong style="color:#ae3520;">Type Parameter and Type Argument</strong> 术语: 许多开发人员互换使用术语 "type parameter" 和 "type argument"，但两者并不相同。在编码时，需要提供 <strong style="color:#ae3520;">类型参数（type arguments）</strong> 以创建 <strong style="color:#ae3520;">参数化类型（parameterized type）</strong>。因此，`Foo<T>` 中的 `T` 是 type parameter，`Foo<String> f` 中的 `String` 是 type argument。

与任何其他变量声明一样，此代码实际上并不创建新的 Box 实例对象。它只是声明 integerBox 将保存对 "`Box` of `Integer`" 的引用，这就是   `Box<Integer>` 的含义。

<strong style="color:#ae3520;">An invocation of a generic type is generally known as a *parameterized type*</strong> - <span style="font-size:13px;color:#909399;">泛型类型的调用通常被称为参数化类型。</span>

要实例化此类，请像往常一样使用 `new` 关键字，但将 `<Integer>` 放在类名和括号之间：

```java
Box<Integer> integerBox = new Box<Integer>();
```

### The Diamond<span style="font-size:13px;color:#909399;"> - 菱形？</span> {#the-diamond}

在 Java SE 7 以及更高版本中，<strong style="color:#ae3520;">只要编译器可以从上下文中确定或推断出类型参数，就可以用一组空的类型参数(<>)来替换泛型类构造函数所需的类型参数</strong>。这对尖括号<>，俗称菱形。例如，你可以使用以下语句创建 `Box<Integer >` 的实例：

```java
Box<Integer> integerBox = new Box<>();
```

### 多个类型参数

如前面所述，<strong style="color:#ae3520;">泛型类可以有多个类型参数</strong>。例如，`OrderedPair` 泛型类，它实现了 `Pair` 泛型接口：

```java
public interface Pair<K, V> {
  public K getKey();
  public V getValue();
}

public class OrderedPair<K, V> implements Pair<K, V> {
  private K key;
  private V value;

  public OrderedPair(K key, V value) {
    this.key = key;
    this.value = value;
  }

  public K getKey()	{ return key; }
  public V getValue() { return value; }
}
```

以下语句创建了 `OrderedPair` 类的两个实例：

```java
Pair<String, Integer> p1 = new OrderedPair<String, Integer>("Even", 8);
Pair<String, String>  p2 = new OrderedPair<String, String>("hello", "world");
```

代码 `new OrderedPair<String, Integer>` 将 `K` 实例化为 `String`，将 `V` 实例化为 `Integer`。因此，`OrderedPair` 构造函数的参数类型分别为 `String` 和 `Integer`。由于自动装箱，将 `String` 和 `int` 传递给类是有效的。

正如 [The Diamond](#the-diamond) 中所提到的，由于 Java 编译器可以从声明 `OrderedPair<String, Integer>` 推断出 `K` 和 `V` 类型，因此可以使用菱形符号来缩短这些语句：

```java
OrderedPair<String, Integer> p1 = new OrderedPair<>("Even", 8);
OrderedPair<String, String>  p2 = new OrderedPair<>("hello", "world");
```

要创建泛型接口，请遵循与创建泛型类相同的约定。

### Parameterized Types<span style="font-size:13px;color:#909399;"> - 参数化类型</span>

你还可以使用参数化类型（如 `List<String>`）来替换类型参数（`K` 或者 `V`）。如下所示：

```java
OrderedPair<String, Box<Integer>> p = new OrderedPair<>("primes", new Box<Integer>(...));
```

### Raw Types<span style="font-size:13px;color:#909399;"> - 原始类型</span>

<strong style="color:#ae3520;">A *raw type* is the name of a generic class or interface without any type arguments</strong> - <span style="font-size:13px;color:#909399;">原始类型是没有任何类型参数的泛型类或接口的名称。</span>

例如，给定 `Box` 泛型类：

```java
public class Box<T> {
    public void set(T t) { /* ... */ }
    // ...
}
```

<strong style="color:#ae3520;">To create a parameterized type of `Box<T>`, you supply an actual type argument for the formal type parameter `T`</strong>: - <span style="font-size:13px;color:#909399;">要创建参数化类型 `Box<T>` ，你需要为形式类型参数 `T` 提供实际类型参数：</span>

```java
Box<Integer> intBox = new Box<>();
```

如果省略实际类型参数，你将创建 `Box<T>` 的原始类型：

```java
Box rawBox = new Box();
```

因此，`Box` 是泛型类型 `Box<T>` 的原始类型。但是，非泛型类或接口类型不属于原始类型。

原始类型出现在遗留代码中，是因为许多 API 类 (如集合类) 在 JDK1.5 之前不是通用的。使用原始类型时，你本质上会获得预泛型行为 - `Box` 为你提供 `Object` 。<strong style="color:#ae3520;">为了向后兼容，允许将参数化类型分配给其原始类型</strong>：

```java
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;               // OK
```

但是，如果将原始类型分配给参数化类型，则会收到警告：

```java
Box rawBox = new Box();           // rawBox is a raw type of Box<T>
Box<Integer> intBox = rawBox;     // warning: unchecked conversion
```

如果你使用原始类型调用相应泛型类型中定义的泛型方法，也会收到警告：

```java
Box<String> stringBox = new Box<>();
Box rawBox = stringBox;
rawBox.set(8);  // warning: unchecked invocation to set(T)
```

该警告表明使用原始类型绕过泛型类型检查，将不安全代码的捕获推迟到运行时。因此，在这种情况下你应该尽量避免使用原始类型。

[类型擦除](#type-erasure)部分提供了有关 Java 编译器如何使用原始类型的更多信息。

#### 未经检查的错误消息

如前所述，将遗留代码与泛型代码混在一起时，你可能会遇到类似于以下内容的警告消息：

```
Note: Example.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
```

在使用原始类型的旧 API 时，可能会发生这种情况，如以下示例所示：

```java
public class WarningDemo {
  public static void main(String[] args){
    Box<Integer> bi;
    bi = createBox();
  }

  static Box createBox(){
    return new Box();
  }
}
```

术语 “unchecked” 意味着编译器没有足够的类型信息来执行确保类型安全所需的所有类型检查。虽然编译器给出了提示，但是默认情况下，“unchecked” 警告被禁用。要查看所有 “unchecked” 警告，请使用 -Xlint:unchecked 进行重新编译。

使用 -Xlint:unchecked 重新编译前面的示例会显示以下附加信息：

```
WarningDemo.java:4: warning: [unchecked] unchecked conversion
found   : Box
required: Box<java.lang.Integer>
        bi = createBox();
                      ^
1 warning
```

要完全禁用未检查的警告，请使用 `-Xlint:-unchecked` 标志。 `@SuppressWarnings("unchecked")` 注释会抑制未经检查的警告。

## Generic Methods<span style="font-size:13px;color:#909399;"> - 泛型方法</span> {#generic-methods}

<strong style="color:#ae3520;">*Generic methods* are methods that introduce their own type parameters.</strong> This is similar to declaring a generic type, <strong style="color:#ae3520;">but the type parameter's scope is limited to the method where it is declared.</strong> Static and non-static generic methods are allowed, as well as generic class constructors. - <span style="font-size:13px;color:#909399;">泛型方法是指那些引入自己的类型参数的方法。这类似于声明一个泛型类型，但是类型参数的作用范围仅限于声明它的方法内。允许声明静态和非静态的泛型方法，以及泛型类的构造函数。</span>

<strong style="color:#ae3520;">泛型方法的语法包括尖括号内的类型参数列表，该列表出现在方法的返回类型之前</strong>。对于静态泛型方法，类型参数部分必须出现在方法的返回类型之前。

`Util` 类中包含一个泛型方法 `compare` ，它用于比较两个 `Pair` 对象：

```java
public class Util {
  public static <K, V> boolean compare(Pair<K, V> p1, Pair<K, V> p2) {
    return p1.getKey().equals(p2.getKey()) &&
      p1.getValue().equals(p2.getValue());
  }
}

public class Pair<K, V> {
  private K key;
  private V value;

  public Pair(K key, V value) {
    this.key = key;
    this.value = value;
  }

  public void setKey(K key) { this.key = key; }
  public void setValue(V value) { this.value = value; }
  public K getKey()   { return key; }
  public V getValue() { return value; }
}
```

调用此方法的完整语法是：

```java
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.<Integer, String>compare(p1, p2);
```

类型已经明确提供，如上面后一行代码所示。通常，这<strong style="color:#ae3520;">可以省略，我们不需要像泛型类那样手动指定具体类型，因为编译器会根据你的调用自动推导出具体所需的类型</strong>：

```java
Pair<Integer, String> p1 = new Pair<>(1, "apple");
Pair<Integer, String> p2 = new Pair<>(2, "pear");
boolean same = Util.compare(p1, p2);
```

<strong style="color:#ae3520;">此功能称为类型推断 *type inference*，允许你像普通方法一样调用泛型方法，而不用在尖括号之间指定类型</strong>。该主题将在下一节[类型推断](#type-infrence)中进一步讨论。

## Bounded Type Parameters<span style="font-size:13px;color:#909399;"> - 有界类型参数</span>

There may be times when you want to <strong style="color:#ae3520;">restrict the types that can be used as type arguments in a parameterized type</strong>. - <span style="font-size:13px;color:#909399;">有时你可能希望限制可用作参数化类型中的类型参数的类型。</span>

例如，对数字进行操作的方法可能只想接受 `Number` 或其子类的实例。这就是有界类型参数的用途。

<strong style="color:#ae3520;">To declare a bounded type parameter, list the type parameter's name, followed by the `extends` keyword, followed by its *upper bound*</strong>, which in this example is `Number`. - <span style="font-size:13px;color:#909399;">要声明有界类型参数，请列出类型参数的名称，然后跟 `extends` 关键字，然后是其上限，在本例中为 `Number`。</span>

```java
public class Box<T> {
  private T t;          

  public void set(T t) {
    this.t = t;
  }

  public T get() {
    return t;
  }

  public <U extends Number> void inspect(U u){
    System.out.println("T: " + t.getClass().getName());
    System.out.println("U: " + u.getClass().getName());
  }

  public static void main(String[] args) {
    Box<Integer> integerBox = new Box<Integer>();
    integerBox.set(new Integer(10));
    integerBox.inspect("some text"); // error: this is still String!
  }
}
```

通过修改我们的泛型方法以包含此有界类型参数，现在将编译失败，因为我们对 `inspect` 泛型方法的调用仍然包含 `String`：

```
Box.java:21: <U>inspect(U) in Box<java.lang.Integer> cannot
  be applied to (java.lang.String)
                        integerBox.inspect("10");
                                  ^
1 error
```

<strong style="color:#ae3520;">In addition to limiting the types you can use to instantiate a generic type, bounded type parameters allow you to invoke methods defined in the bounds</strong>: - <span style="font-size:13px;color:#909399;">除了限制可用于实例化泛型类型的类型之外，有界类型参数还允许你调用边界中定义的方法：</span>

如下所示，在 `isEven` 方法中通过 `n` 调用 `Integer` 类中定义的 `intValue` 方法。

```java
public class NaturalNumber<T extends Integer> {
  private T n;

  public NaturalNumber(T n)  { this.n = n; }

  public boolean isEven() {
    return n.intValue() % 2 == 0;
  }

  // ...
}
```

### Multiple Bounds<span style="font-size:13px;color:#909399;"> - 多重界限</span>

前面的示例说明了如何使用具有单个边界的类型参数，但类型参数可以具有多个边界：

```java
<T extends B1 & B2 & B3>
```

<strong style="color:#ae3520;">A type variable with multiple bounds is a subtype of all the types listed in the bound. If one of the bounds is a class, it must be specified first</strong>. - <span style="font-size:13px;color:#909399;">具有多个界限的类型变量是界限中列出的所有类型的子类型。如果其中一个界限是类，则必须首先指定它。</span>

```java
class A { /* ... */ }
interface B { /* ... */ }
interface C { /* ... */ }

class D<T extends A & B & C> { /* ... */ }
```

如果没有首先指定边界 A 的话，则会出现编译时错误：

```java
class D<T extends B & A & C> { /* ... */ }  // compile-time error
```

### Generic Methods and Bounded Type Parameters<span style="font-size:13px;color:#909399;"> - 泛型方法和有界类型参数</span>

有界类型参数是实现泛型算法的关键。如以下方法所示，该方法对数组 T[] 中大于 elem 元素的元素进行计数。

```java
public static <T> int countGreaterThan(T[] anArray, T elem) {
  int count = 0;
  for (T e : anArray)
    if (e > elem)  // compiler error
      ++count;
  return count;
}
```

该方法的实现很简单，但无法编译，因为大于运算符 ( `>` ) 仅适用于基本类型，例如 `short`、`int`、`double`、`long`、`float`、`byte` 和 `char`。你不能使用 `>` 运算符来比较对象。要解决此问题，请使用由 `Comparable<T>` 接口限定的类型参数：

```java
public interface Comparable<T> {
  public int compareTo(T o);
}
```

The resulting code will be:

```java
public static <T extends Comparable<T>> int countGreaterThan(T[] anArray, T elem) {
  int count = 0;
  for (T e : anArray)
    if (e.compareTo(elem) > 0)
      ++count;
  return count;
}
```

## Generics, Inheritance, and Subtypes<span style="font-size:13px;color:#909399;"> - 泛型、继承与子类型</span> {#generics-inheritance-and-subtypes}

如你所知，只要类型兼容，就可以将一种类型的对象分配给另一种类型的对象。例如，你可以将 `Integer` 分配给 `Object` ，因为 `Object` 是 `Integer` 的超类型之一：

```java
Object someObject = new Object();
Integer someInteger = new Integer(10);
someObject = someInteger;   // OK
```

在面向对象的术语中，这称为 “is - <span style="font-size:13px;color:#909399;">是</span>” 的关系。由于 `Integer` 是 `Object` 的一种，因此允许赋值。但 `Integer` 也是 `Number` 的一种，因此以下代码也是有效的：

```java
public void someMethod(Number n) { /* ... */ }

someMethod(new Integer(10));   // OK
someMethod(new Double(10.1));   // OK
```

<strong style="color:#ae3520;">The same is also true with generics</strong>. - <span style="font-size:13px;color:#909399;">泛型同样如此。</span> 

你可以执行泛型类型调用，传递 `Number` 作为其类型参数，并且如果该参数与 `Number` 兼容，将允许任何后续的 `add` 调用：

```java
Box<Number> box = new Box<Number>();
box.add(new Integer(10));   // OK
box.add(new Double(10.1));  // OK
```

如以下方法所示：

```java
public void boxTest(Box<Number> n) { /* ... */ }
```

它接受什么类型的参数？通过查看它的签名，你可以看到它接受一个类型为 `Box<Number>` 的参数。但是，这是什么意思？你是否可以按照你的预期传入 `Box<Integer>` 或 `Box<Double>` ？答案是 “No”，因为 `Box<Integer>` 和 `Box<Double>` 并不是 `Box<Number>` 的子类。

这是在使用泛型编程时常见的误解，但它是一个需要学习的重要概念。

![Box<Integer> is not a subtype of Box<Number>](https://cdn.jsdelivr.net/gh/xihuanxiaorang/img2/202407251454061.gif)

`Box<Integer>` is not a subtype of `Box<Number>` even though `Integer` is a subtype of `Number`.

> [!note]
>
> 给定两个具体类型 `A` 和 `B` （例如 `Number` 和 `Integer`），`MyClass<A>` 与 `MyClass<B>` 没有任何关系，无论 `A` 和 `B` 是否相关。 `MyClass<A>` 和 `MyClass<B>` 的共同父级是 `Object` 。

### Generic Classes and Subtyping<span style="font-size:13px;color:#909399;"> - 泛型类和子类型</span>

<strong style="color:#ae3520;">You can subtype a generic class or interface by extending or implementing it. The relationship between the type parameters of one class or interface and the type parameters of another are determined by the `extends` and `implements` clauses</strong>. - <span style="font-size:13px;color:#909399;">你可以通过扩展或实现泛型类或接口来对其进行子类型化。一个类或接口的类型参数与另一个类或接口的类型参数之间的关系是由 `extends` 和 `implements` 子句决定的。</span>

以 `Collections` 类为例，`ArrayList<E>` 实现 `List<E>`，而 `List<E>` 继承自 `Collection<E>`。因此 `ArrayList<String>` 是 `List<String>` 的子类型，而 `List<String>` 是 `Collection<String>` 的子类型。<strong style="color:#ae3520;">只要不改变类型参数，类型之间的子类型关系就会保持不变</strong>。

![a sample collections hierarchy: ArrayList<String> is a subtype of List<String>, which is a subtype of Collection<String>.](https://cdn.jsdelivr.net/gh/xihuanxiaorang/img2/202407251515648.gif)

A sample `Collections` hierarchy.

现在假设我们要定义自己的集合接口 `PayloadList`，它将泛型类型 `P` 的可选值与每个元素相关联。它的声明可能如下所示：

```java
interface PayloadList<E,P> extends List<E> {
  void setPayload(int index, P val);
  ...
}
```

`PayloadList` 的以下参数化是 `List<String>` 的子类型：

- `PayloadList<String,String>`
- `PayloadList<String,Integer>`
- `PayloadList<String,Exception>`

![an example PayLoadList hierarchy: PayloadList<String, String> is a subtype of List<String>, which is a subtype of Collection<String>. At the same level of PayloadList<String,String> is PayloadList<String, Integer> and PayloadList<String, Exceptions>.](https://cdn.jsdelivr.net/gh/xihuanxiaorang/img2/202407251521589.gif)

A sample `PayloadList` hierarchy.

## Type Inference<span style="font-size:13px;color:#909399;"> - 类型推断</span> {#type-infrence}

类型推断是 Java 编译器的一种能力，它能够查看每个方法调用及其对应的声明，以确定使该调用适用的类型参数（或参数）。推断算法确定参数的类型，并在可用的情况下，确定被赋值或返回的结果类型。最后，推断算法<strong style="color:#ae3520;">尝试找到与所有参数兼容的最具体的类型</strong>。

为了说明最后一点，在下面的示例中，推断确定传递给 `pick` 方法的第二个参数的类型为 `Serializable`：

```java
static <T> T pick(T a1, T a2) { return a2; }
Serializable s = pick("d", new ArrayList<String>());
```

### Type Inference and Generic Methods<span style="font-size:13px;color:#909399;"> - 类型推断与泛型方法</span>

[泛型方法](#generic-methods)向你介绍了<strong style="color:#ae3520;">类型推断，它使你能够像调用普通方法一样调用泛型方法，而无需在尖括号之间指定类型</strong>。如以下示例 `BoxDemo` 所示，它需要 [Box](#box-generic-class) 类：

```java
public class BoxDemo {
  public static <U> void addBox(U u, java.util.List<Box<U>> boxes) {
    Box<U> box = new Box<>();
    box.set(u);
    boxes.add(box);
  }

  public static <U> void outputBoxes(java.util.List<Box<U>> boxes) {
    int counter = 0;
    for (Box<U> box: boxes) {
      U boxContents = box.get();
      System.out.println("Box #" + counter + " contains [" + boxContents.toString() + "]");
      counter++;
    }
  }

  public static void main(String[] args) {
    java.util.ArrayList<Box<Integer>> listOfIntegerBoxes = new java.util.ArrayList<>();
    BoxDemo.<Integer>addBox(Integer.valueOf(10), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
    BoxDemo.addBox(Integer.valueOf(30), listOfIntegerBoxes);
    BoxDemo.outputBoxes(listOfIntegerBoxes);
  }
}
```

以下是此示例的输出：

```
Box #0 contains [10]
Box #1 contains [20]
Box #2 contains [30]
```

泛型方法 `addBox` 定义了一个名为 `U` 的类型参数。<strong style="color:#ae3520;">通常，Java 编译器能够推断泛型方法调用中的类型参数</strong>。因此，在大多数情况下，你不需要显式指定它们。例如，要调用泛型方法 `addBox`，你可以通过类型实参来指定类型参数，如下所示：

```java
BoxDemo.<Integer>addBox(Integer.valueOf(10), listOfIntegerBoxes);
```

或者，如果你省略了类型实参，Java 编译器会自动从方法的参数中推断出类型参数是 `Integer`：

```java
BoxDemo.addBox(Integer.valueOf(20), listOfIntegerBoxes);
```

### Type Inference and Instantiation of Generic Classes<span style="font-size:13px;color:#909399;"> - 泛型类的类型推断与实例化</span>

<strong style="color:#ae3520;">只要编译器可以从上下文推断类型参数，你就可以用一组空的类型参数（`<>`）替换调用泛型类的构造函数所需的类型参数</strong>。这对尖括号俗称[菱形](#the-diamond)。

例如，如以下变量声明所示：

```java
Map<String, List<String>> myMap = new HashMap<String, List<String>>();
```

你可以用一组空的类型参数（`<>`）替换构造函数的参数化类型：

```java
Map<String, List<String>> myMap = new HashMap<>();
```

> [!note]
>
> <strong style="color:#ae3520;">要在泛型类实例化期间利用类型推断，你必须加上尖括号`<>`</strong>。

在以下示例中，编译器会报未经检查的转换警告，因为 `HashMap()` 构造函数引用 `HashMap` 原始类型，而不是 `Map<String, List<String>>` 类型：

```java
Map<String, List<String>> myMap = new HashMap(); // unchecked conversion warning
```

### Type Inference and Generic Constructors of Generic and Non-Generic Classes<span style="font-size:13px;color:#909399;"> - 类型推断与泛型以及非泛型类的泛型构造器</span>

> [!note]
>
> 无论是在泛型类还是非泛型类中，构造函数都可以是泛型的（换句话说，可以声明它们自己的形式类型参数）。

```java
class MyClass<X> {
  <T> MyClass(T t) {
    // ...
  }
}
```

如以下 `MyClass` 类的实例化所示:

```java
new MyClass<Integer>("")
```

该语句创建了参数化类型 `MyClass<Integer>` 的一个实例；该语句明确指定了类型 `Integer` 作为泛型类 `MyClass<X>` 的形式类型参数 `X`。请注意，这个泛型类的构造器包含了一个形式类型参数 `T`。编译器推断出类型 `String` 作为这个泛型类构造器的形式类型参数 `T` 的类型（因为这个构造器的实际参数是一个 `String` 对象）。

Java SE 7 之前的版本的编译器能够推断出泛型构造函数的实际类型参数，类似于泛型方法。然而，Java SE 7 以及之后版本的编译器能够在你使用菱形（`<>`）操作符时推断出实例化泛型类的实际类型参数。如以下示例所示：

```java
MyClass<Integer> myObject = new MyClass<>("");
```

在此示例中，编译器推断出泛型类 `MyClass<X>` 的形式类型参数 `X` 的类型为 `Integer`，构造函数的形式类型参数 `T` 的类型为 `String`。

> [!note]
>
> 需要注意的是，推断算法仅使用**调用参数**、**目标类型**以及**可能的明显预期返回类型**来推断类型。推断算法不会使用程序后续部分的结果。

### Target Types<span style="font-size:13px;color:#909399;"> - 目标类型</span>

<strong style="color:#ae3520;">Java 编译器利用*目标类型*来推断泛型方法调用的类型参数</strong>。表达式的目标类型是 Java 编译器期望的数据类型，具体取决于表达式出现的位置。如 `Collections.emptyList` 方法，其声明如下所示：

```java
static <T> List<T> emptyList();
```

如以下赋值语句所示：

```java
List<String> listOne = Collections.emptyList();
```

该语句需要一个 `List<String>` 实例；该数据类型是目标类型。由于方法 `emptyList` 返回类型 `List<T>` 的值，因此编译器推断类型参数 `T` 必须是 `String` 类型。或者，你可以直接显式指定类型参数 `T` 的值，如下所示：

```java
List<String> listOne = Collections.<String>emptyList();
```

然而，在这种情况下这是没有必要的。但在其他情况下这是必要的，如以下方法所示：

```java
void processStringList(List<String> stringList) {
    // process stringList
}
```

假如你想使用空列表调用方法 `processStringList`，这在 Java SE 7 中是无法编译的：

```java
processStringList(Collections.emptyList());
```

Java SE 7 编译器会输出类似于以下内容的错误消息：

```
List<Object> cannot be converted to List<String>
```

编译器需要类型参数 `T` 的值，所以它从 `Object` 类型开始。因此，`Collections.emptyList` 的调用返回一个 `List<Object>` 类型的值，这与 `processStringList` 方法不兼容。因此，在 Java SE 7 中，你必须显式指定类型参数的值，如下所示：

```java
processStringList(Collections.<String>emptyList());
```

在 Java SE 8 中，这已不再必要。目标类型的定义已经被扩展到包括方法参数，例如 `processStringList` 方法的参数。在这种情况下，`processStringList` 方法需要一个 `List<String>` 类型的参数。`Collections.emptyList` 方法返回 `List<T>` 类型的值，因此使用目标类型 `List<String>`，编译器推断出类型参数 `T` 的值为 `String`。因此，在 Java SE 8 中，以下语句可以编译通过：

```java
processStringList(Collections.emptyList());
```

## Wildcards<span style="font-size:13px;color:#909399;"> - 通配符</span>

<strong style="color:#ae3520;">在泛型代码中，问号（?）被称为通配符，表示未知类型</strong>。通配符可以在多种情况下使用：作为**参数**、**字段**或**局部变量**的类型；有时也可以作为**返回类型**（尽管更具体的声明是更好的编程实践）。

<strong style="color:#ae3520;">The wildcard is never used as a type argument for a generic method invocation, a generic class instance creation, or a supertype</strong>. - <span style="font-size:13px;color:#909399;">通配符永远不会用作*泛型方法调用*、*泛型类实例创建*或*超类型*的类型参数。</span>

### Upper Bounded Wildcards<span style="font-size:13px;color:#909399;"> - 上限通配符</span> {#upperBounded}

你可以使用上限通配符来放宽对变量的限制。例如，假设你想编写一个适用于 `List<Integer>`、`List<Double>` 和 `List<Number>` 的方法；你可以通过使用上限通配符来实现此目的。

<strong style="color:#ae3520;">To declare an upper-bounded wildcard, use the wildcard character ('`?`'), followed by the `extends` keyword, followed by its *upper bound*</strong>. - <span style="font-size:13px;color:#909399;">要声明上限通配符，请使用通配符（`?`），然后跟 `extends` 关键字，然后是其上限。</span> 

要编写一个可以处理 `Number` 类及其子类（如 `Integer`, `Double`, 和 `Float`）集合的方法，你可以指定 `List<? extends Number>`。术语 `List<Number>` 比 `List<? extends Number>` 更加限制性，因为前者仅匹配 `Number` 类型的集合，而后者则匹配 `Number` 类型或其任何子类的集合。

如以下 `process` 方法所示：

```java
public static void process(List<? extends Foo> list) { /* ... */ }
```

上限通配符 `<? extends Foo>`（其中 `Foo` 代表任意类型）匹配 `Foo` 及其任何子类型。这意味着使用这种方法定义的集合可以容纳 `Foo` 类型的对象以及 `Foo` 的任何子类型对象。`process` 方法可以将集合元素当作 `Foo` 类型来访问：

```java
public static void process(List<? extends Foo> list) {
  for (Foo elem : list) {
    // ...
  }
}
```

在 `foreach` 循环中，变量 `elem` 会迭代集合中的每个元素。现在，`Foo` 类中定义的任何方法都可以在 `elem` 上使用。

`sumOfList` 方法返回集合中数字的总和：

```java
public static double sumOfList(List<? extends Number> list) {
  double s = 0.0;
  for (Number n : list)
    s += n.doubleValue();
  return s;
}
```

以下代码使用了一个 `Integer` 对象的集合，并输出了 `sum = 6.0`：

```java
List<Integer> li = Arrays.asList(1, 2, 3);
System.out.println("sum = " + sumOfList(li));
```

一个包含 `Double` 值的集合也可以使用相同的 `sumOfList` 方法。以下代码将输出 `sum = 7.0`：

```java
List<Double> ld = Arrays.asList(1.2, 2.3, 3.5);
System.out.println("sum = " + sumOfList(ld));
```

### Unbounded Wildcards<span style="font-size:13px;color:#909399;"> - 无界通配符</span>

<strong style="color:#ae3520;">The unbounded wildcard type is specified using the wildcard character (`?`)</strong>. - <span style="font-size:13px;color:#909399;">无界通配符类型使用通配符（`?`）指定。</span>例如 `List<?>`，这被称为未知类型集合。在以下两种情况下，使用无界通配符是一种有用的策略：

1. **如果你正在编写一个方法，该方法可以使用 `Object` 类提供的功能实现。**
   - 例如，如果你的方法只需要遍历列表中的元素而不关心元素的具体类型，你可以使用 `List<?>`。
2. **当代码正在使用泛型类中不依赖于类型参数的方法时。**
   - 例如，`List.size()` 或 `List.clear()` 方法不依赖于列表中元素的具体类型，因此可以使用 `List<?>`。
   - 同样，`Class<?>` 经常被使用，因为 `Class<T>` 类中的大多数方法都不依赖于类型参数 `T`。

如以下 `printList` 方法所示：

```java
public static void printList(List<Object> list) {
  for (Object elem : list)
    System.out.println(elem + " ");
  System.out.println();
}
```

为了实现一个能够打印任何类型集合的目标，我们需要使用无界通配符 `List<?>`。原来的 `printList` 方法只能够打印 `List<Object>` 类型的列表，因为它将列表作为 `List<Object>` 类型处理。这限制了它的通用性，因为 `List<Integer>`, `List<String>`, `List<Double>` 等并不是 `List<Object>` 的子类型。

```java
public static void printList(List<?> list) {
  for (Object elem: list)
    System.out.print(elem + " ");
  System.out.println();
}
```

因为<strong style="color:#ae3520;">对于任何具体的类型 `A`，`List<A>` 是 `List<?>` 的子类型</strong>，所以你可以使用 `printList` 方法来打印任何类型的集合。

```java
List<Integer> li = Arrays.asList(1, 2, 3);
List<String>  ls = Arrays.asList("one", "two", "three");
printList(li);
printList(ls);
```

> [!note]
>
> 重要的是要注意 `List<Object>` 和 `List<?>` 并不相同。你可以将 `Object` 或其任何子类型插入到 `List<Object>` 中。但是，你只能将 `null` 插入到 `List<?>` 中。[通配符使用指南](#wildcardGuidelines)部分提供了有关如何确定在给定情况下应使用哪种通配符（如果有）的更多信息。
>
> `List<Object>` vs `List<?>`
>
> 1. **`List<Object>`**
>
>    - 表示一个可以包含任何 `Object` 类型或其子类型的集合。
>    - 可以向集合中添加任何 `Object` 类型或其子类型的元素。
>    - 可以从集合中取出元素，并将它们赋值给 `Object` 类型的变量或其他子类型的变量。
>
>    ```java
>    List<Object> objectList = new ArrayList<>();
>    objectList.add("Hello"); // 合法
>    objectList.add(123); // 合法
>    ```
>
> 2. **`List<?>`**
>
>    - 表示一个未知类型的集合。
>    - <strong style="color:#ae3520;">不能向集合中添加任何元素，因为集合的确切类型未知</strong>。 - <span style="font-size:13px;color:#909399;">当你使用 `List<?>` 时，你就是在告诉 Java 编译器你不知道集合中的元素类型到底是什么。因此，Java 编译器为了类型安全，不允许你向这样的集合中添加任何元素（除 `null` 外），因为你不知道集合中已经存储了什么类型的元素。</span>
>    - 由于集合的确切类型未知，<strong style="color:#ae3520;">你不能从集合中读取元素，除非将它们赋值给 `Object` 类型的变量</strong>。
>
>    ```java
>    List<?> unknownList = new ArrayList<>();
>    // unknownList.add("Hello"); // 编译错误
>    // unknownList.add(123); // 编译错误
>    unknownList.add(null); // 合法，因为 null 可以赋值给任何类型的引用
>    ```

### Lower Bounded Wildcards<span style="font-size:13px;color:#909399;"> - 下限通配符</span>

<strong style="color:#ae3520;">The [Upper Bounded Wildcards](#upperBounded) section shows that an upper bounded wildcard restricts the unknown type to be a specific type or a subtype of that type and is represented using the `extends` keyword. In a similar way, a *lower bounded* wildcard restricts the unknown type to be a specific type or a *super type* of that type</strong>. - <span style="font-size:13px;color:#909399;">上限通配符部分展示了上限通配符限制未知类型为特定类型或该类型的子类型，并使用 `extends` 关键字表示。类似地，下限通配符限制未知类型为特定类型或该类型的超类型。</span>

<strong style="color:#ae3520;">A lower bounded wildcard is expressed using the wildcard character ('`?`'), following by the `super` keyword, followed by its *lower bound*: `<? super A>`</strong>. - <span style="font-size:13px;color:#909399;">下限通配符使用问号（`?`）通配符表示，接着是 `super` 关键字，然后是其下限：`<? super A>`。</span>

> [!note]
>
> You can specify an upper bound for a wildcard, or you can specify a lower bound, but you cannot specify both. - <span style="font-size:13px;color:#909399;">你可以为通配符指定一个上限，或者指定一个下限，但不能同时指定两者。</span>

假设你想编写一个方法，该方法可以将 `Integer` 对象放入集合中。为了最大限度地提高灵活性，你希望该方法可以处理 `List<Integer>`、`List<Number>` 和 `List<Object>` 等任何可以存放 `Integer` 值的集合。

要编写一个可以处理 `Integer` 类及其超类型（如 `Integer`, `Number`, 和 `Object`）的集合的方法，你可以指定 `List<? super Integer>`。术语 `List<Integer>` 比 `List<? super Integer>` 更具限制性，因为前者仅匹配 `Integer` 类型的集合，而后者则匹配任何可以存放 `Integer` 值的集合类型。

以下代码将数字 1 到 10 添加到集合的末尾：

```java
public static void addNumbers(List<? super Integer> list) {
  for (int i = 1; i <= 10; i++) {
    list.add(i);
  }
}
```

[通配符使用指南](#wildcardGuidelines)部分提供了有关何时使用上限通配符和何时使用下限通配符的指导。

### Wildcards and Subtyping<span style="font-size:13px;color:#909399;"> - 通配符与子类型</span>

正如在[泛型、继承和子类型](#generics-inheritance-and-subtypes)中所述，仅仅因为两个类型之间存在关系，并不意味着它们的泛型类或接口之间也存在关系。然而，你可以使用通配符来创建泛型类或接口之间的关系。

给定以下两个普通（非泛型）类：

```java
class A { /* ... */ }
class B extends A { /* ... */ }
```

编写以下代码是合理的：

```java
B b = new B();
A a = b;
```

这个例子展示了普通类的继承遵循子类型的规则：如果类 `B` 扩展了类 `A`，那么类 `B` 是类 `A` 的子类型。然而，这个规则不适用于泛型类型。

```java
List<B> lb = new ArrayList<>();
List<A> la = lb;   // compile-time error
```

`Integer` 是 `Number` 的子类型，那么 `List<Integer>` 和 `List<Number>` 之间的关系是什么？

![that the common parent of List<Number> and List<Integer> is the list of unknown type](https://cdn.jsdelivr.net/gh/xihuanxiaorang/img2/202407252227172.gif)

The common parent is `List<?>`.

虽然 `Integer` 是 `Number` 的子类型，但 `List<Integer>` 并不是 `List<Number>` 的子类型，实际上这两种类型之间并没有直接的关系。`List<Number>` 和 `List<Integer>` 的共同父类型是 `List<?>`。

为了在这些类之间创建关系，以便可以通过 `List<Integer>` 的元素访问 `Number` 的方法，可以使用上限通配符。

```java
List<? extends Integer> intList = new ArrayList<>();
List<? extends Number>  numList = intList;  // OK. List<? extends Integer> is a subtype of List<? extends Number>
```

由于 `Integer` 是 `Number` 的子类型，并且 `numList` 是 `Number` 对象的集合，现在在 `intList`（`Integer` 对象的集合）和 `numList` 之间存在一种关系。如下图所示，展示了使用上限和下限通配符声明的多个 `List` 类之间的关系。

![that List<Integer> is a subtype of both List<? extends Integer> and List<?super Integer>. List<? extends Integer> is a subtype of List<? extends Number> which is a subtype of List<?>. List<Number> is a subtype of List<? super Number> and List>? extends Number>. List<? super Number> is a subtype of List<? super Integer> which is a subtype of List<?>.](https://cdn.jsdelivr.net/gh/xihuanxiaorang/img2/202407252233762.gif)

A hierarchy of several generic `List` class declarations.

[通配符使用指南](#wildcardGuidelines)部分提供了有关使用上限和下限通配符的后果的更多信息。

### Wildcard Capture and Helper Methods<span style="font-size:13px;color:#909399;"> - 通配符捕获与辅助方法</span>

在某些情况下，编译器会推断出通配符的具体类型。例如，集合可能被定义为 `List<?>`，但在评估表达式时，编译器可以根据代码推断出一个特定的类型。这种情形被称为<strong style="color:#ae3520;">通配符捕获</strong>。

在大多数情况下，你不需要特别关注通配符捕获，除非你看到包含 "capture of" 的错误消息。

[WildcardError](https://docs.oracle.com/javase/tutorial/java/generics/examples/WildcardError.java) 示例在编译时会产生捕获错误：

```java
import java.util.List;

public class WildcardError {
  void foo(List<?> i) {
    i.set(0, i.get(0));
  }
}
```

在这个例子中，编译器处理输入参数 `i` 为 `Object` 类型。当 `foo` 方法调用 `List.set(int, E)` 时，编译器无法确认正在插入到集合中的对象类型，从而产生错误。当这类错误发生时，通常意味着编译器认为你正在为变量分配错误的类型。<strong style="color:#ae3520;">Java 语言中引入泛型的目的就是为了在编译时强制类型安全</strong>。

在这个示例中，当我们使用 Oracle 的 JDK 7 的 `javac` 编译器编译代码时，会产生以下错误：

```
WildcardError.java:6: error: method set in interface List<E> cannot be applied to given types;
    i.set(0, i.get(0));
     ^
  required: int,CAP#1
  found: int,Object
  reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion
  where E is a type-variable:
    E extends Object declared in interface List
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
1 error
```

在这个示例中，代码试图执行一个安全的操作，但由于编译器无法确认元素类型是否与集合中的元素类型相匹配，产生了错误。你可以通过编写一个私有的辅助方法来解决这个问题，该方法可以捕获通配符。具体来说，你可以通过创建私有的辅助方法 `fooHelper` 来解决这个问题，如下所示：

```java
public class WildcardFixed {
  void foo(List<?> i) {
    fooHelper(i);
  }

  // Helper method created so that the wildcard can be captured
  // through type inference.
  private <T> void fooHelper(List<T> l) {
    l.set(0, l.get(0));
  }
}
```

通过使用辅助方法，编译器使用类型推断来确定 `T` 是 `CAP#1`（捕获变量）在调用中的类型。现在这个示例可以成功编译。

按照约定，辅助方法通常命名为 *originalMethodName*Helper。

现在让我们考虑一个更复杂的示例 [WildcardErrorBad](https://docs.oracle.com/javase/tutorial/java/generics/examples/WildcardErrorBad.java)，在这个示例中，我们将探讨如何处理更复杂的情况，特别是在使用多个集合和不同类型参数时可能出现的问题。

```java
import java.util.List;

public class WildcardErrorBad {
  void swapFirst(List<? extends Number> l1, List<? extends Number> l2) {
    Number temp = l1.get(0);
    l1.set(0, l2.get(0)); // expected a CAP#1 extends Number,
    // got a CAP#2 extends Number;
    // same bound, but different types
    l2.set(0, temp);	    // expected a CAP#1 extends Number,
    // got a Number
  }
}
```

在这个示例中，代码试图执行一个不安全的操作。例如，考虑以下对 `swapFirst` 方法的调用：

```java
List<Integer> li = Arrays.asList(1, 2, 3);
List<Double>  ld = Arrays.asList(10.10, 20.20, 30.30);
swapFirst(li, ld);
```

虽然 `List<Integer>` 和 `List<Double>` 都满足 `List<? extends Number>` 的条件，但从 `Integer` 类型的列表中取出一个元素并尝试将其放入 `Double` 类型的列表中显然是不正确的。

使用 Oracle's JDK 的 `javac` 编译器编译这段代码会产生以下错误：

```
WildcardErrorBad.java:7: error: method set in interface List<E> cannot be applied to given types;
      l1.set(0, l2.get(0)); // expected a CAP#1 extends Number,
        ^
  required: int,CAP#1
  found: int,Number
  reason: actual argument Number cannot be converted to CAP#1 by method invocation conversion
  where E is a type-variable:
    E extends Object declared in interface List
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Number from capture of ? extends Number
WildcardErrorBad.java:10: error: method set in interface List<E> cannot be applied to given types;
      l2.set(0, temp);      // expected a CAP#1 extends Number,
        ^
  required: int,CAP#1
  found: int,Number
  reason: actual argument Number cannot be converted to CAP#1 by method invocation conversion
  where E is a type-variable:
    E extends Object declared in interface List
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Number from capture of ? extends Number
WildcardErrorBad.java:15: error: method set in interface List<E> cannot be applied to given types;
        i.set(0, i.get(0));
         ^
  required: int,CAP#1
  found: int,Object
  reason: actual argument Object cannot be converted to CAP#1 by method invocation conversion
  where E is a type-variable:
    E extends Object declared in interface List
  where CAP#1 is a fresh type-variable:
    CAP#1 extends Object from capture of ?
3 errors
```

没有辅助方法可以绕过这个问题，因为代码本质上是错误的：从 `Integer` 类型的集合中取出一个元素并尝试将其放入 `Double` 类型的集合中显然是不正确的。

### Guidelines for Wildcard Use<span style="font-size:13px;color:#909399;"> - 通配符使用指南</span> {#wildcardGuidelines}

学习如何在使用泛型编程时正确选择上限通配符 (`<? extends T>`) 和下限通配符 (`<? super T>`) 是一个常见的挑战。本页面提供了一些指导原则，帮助你在设计代码时做出正确的选择。

出于讨论的目的，将变量视为提供两种功能之一是有帮助的：

1. "in" 变量：
   - "in" 变量为代码提供数据。想象一个具有两个参数的复制方法 `copy(src, dest)`。`src` 参数提供了要复制的数据，因此它是 "in" 参数。
2. "out" 变量：
   - "out" 变量持有数据供其他地方使用。在复制示例 `copy(src, dest)` 中，`dest` 参数接受数据，因此它是 "out" 参数。

当然，有些变量同时用于 "in" 和 "out" 目的——这种情况也在指导原则中得到了考虑。

你可以使用 "in" 和 "out" 原则来决定是否使用通配符以及使用哪种类型的通配符。以下列表提供了指导原则：

- <strong style="color:#ae3520;">An "in" variable is defined with an upper bounded wildcard, using the `extends` keyword</strong>. - <span style="font-size:13px;color:#909399;"> "in" 变量使用上限通配符定义，使用 `extends` 关键字。</span>
- <strong style="color:#ae3520;">An "out" variable is defined with a lower bounded wildcard, using the `super` keyword</strong>. - <span style="font-size:13px;color:#909399;"> “out” 变量使用下限通配符定义，使用 `super` 关键字。</span>
- <strong style="color:#ae3520;">In the case where the "in" variable can be accessed using methods defined in the `Object` class, use an unbounded wildcard</strong>. - <span style="font-size:13px;color:#909399;">在 "in" 变量可以使用 `Object` 类定义的方法的情况下，使用无界通配符。</span>
- <strong style="color:#ae3520;">In the case where the code needs to access the variable as both an "in" and an "out" variable, do not use a wildcard</strong>. - <span style="font-size:13px;color:#909399;">在代码需要将变量同时作为 "in" 和 "out" 变量访问的情况下，不要使用通配符。</span>

这些指导原则不适用于方法的返回类型。<strong style="color:#ae3520;">应该避免使用通配符作为返回类型</strong>，因为这会迫使使用代码的程序员处理通配符。

<strong style="color:#ae3520;">由 `List<? extends ...>` 定义的集合可以简单地认为是只读的，不过这并不是严格意义上的只读</strong>。假设你有以下两个类：

```java
class NaturalNumber {
  private int i;

  public NaturalNumber(int i) { this.i = i; }
  // ...
}

class EvenNumber extends NaturalNumber {
  public EvenNumber(int i) { super(i); }
  // ...
}
```

如以下代码所示：

```java
List<EvenNumber> le = new ArrayList<>();
List<? extends NaturalNumber> ln = le;
ln.add(new NaturalNumber(35));  // compile-time error
```

由于 `List<EvenNumber>` 是 `List<? extends NaturalNumber>` 的子类型，所以你可以将 `le` 赋值给 `ln`。但是你不能使用 `ln` 向 `EvenNumber` 的集合中添加一个自然数。对于该集合，以下操作是可行的：

- 你可以添加 `null`。
- 你可以调用 `clear` 方法。
- 你可以获取迭代器并调用 `remove` 方法。
- 你可以捕获通配符，并写入从集合中读取的元素。

你可以看到，由 `List<? extends NaturalNumber>` 定义的集合并不是严格意义上的只读，但是你可以将其视为只读，因为你不能向集合中存储新元素或更改现有元素。

####

## Type Erasure<span style="font-size:13px;color:#909399;"> - 类型擦除</span> {#type-erasure}

泛型被引入到 Java 语言中，<strong style="color:#ae3520;">旨在提供更严格的编译时类型检查并支持泛型编程</strong>。为了实现泛型，Java 编译器应用类型擦除来：

1. **替换泛型类型中的所有类型参数**:
   - 将所有泛型类型中的类型参数替换为其边界类型或 `Object`（如果类型参数未被限定）。
   - 因此产生的字节码只包含普通的类、接口和方法。
2. **插入必要的类型转换**:
   - 如果必要，插入类型转换以保持类型安全。
3. **生成桥接方法**:
   - 生成桥接方法以保持扩展泛型类型中的多态性。

类型擦除确保不会为参数化类型创建新的类；因此，泛型在运行时不会带来额外开销。

### Erasure of Generic Types<span style="font-size:13px;color:#909399;"> - 泛型类型的擦除</span>

<strong style="color:#ae3520;">在类型擦除过程中，Java 编译器擦除所有类型参数，并将其替换为相应的第一个边界类型（如果类型参数有界），或者替换为 `Object`（如果类型参数无界）</strong>。

如以下表示单链表中节点的泛型类所示：

```java
public class Node<T> {
  private T data;
  private Node<T> next;

  public Node(T data, Node<T> next) {
    this.data = data;
    this.next = next;
  }

  public T getData() { return data; }
  // ...
}
```

因为类型参数 `T` 是无界的，Java 编译器将其替换为 `Object`：

```java
public class Node {
  private Object data;
  private Node next;

  public Node(Object data, Node next) {
    this.data = data;
    this.next = next;
  }

  public Object getData() { return data; }
  // ...
}
```

在以下示例中，泛型 `Node` 类使用了一个有界的类型参数：

```java
public class Node<T extends Comparable<T>> {
  private T data;
  private Node<T> next;

  public Node(T data, Node<T> next) {
    this.data = data;
    this.next = next;
  }

  public T getData() { return data; }
  // ...
}
```

Java 编译器将有界的类型参数 `T` 替换为其第一个边界类 `Comparable`：

```java
public class Node {
  private Comparable data;
  private Node next;

  public Node(Comparable data, Node next) {
    this.data = data;
    this.next = next;
  }

  public Comparable getData() { return data; }
  // ...
}
```

### Erasure of Generic Methods<span style="font-size:13px;color:#909399;"> - 泛型方法的擦除</span>

Java 编译器还会擦除泛型方法参数中的类型参数。如以下泛型方法所示：

```java
// Counts the number of occurrences of elem in anArray.
public static <T> int count(T[] anArray, T elem) {
  int cnt = 0;
  for (T e : anArray)
    if (e.equals(elem))
      ++cnt;
  return cnt;
}
```

因为类型参数 `T` 是无界的，Java 编译器将其替换为 `Object`：

```java
public static int count(Object[] anArray, Object elem) {
  int cnt = 0;
  for (Object e : anArray)
    if (e.equals(elem))
      ++cnt;
  return cnt;
}
```

假设以下类被定义：

```java
class Shape { /* ... */ }
class Circle extends Shape { /* ... */ }
class Rectangle extends Shape { /* ... */ }
```

你可以编写一个泛型方法来绘制不同的形状：

```java
public static <T extends Shape> void draw(T shape) { /* ... */ }
```

Java 编译器将类型参数 `T` 替换为 `Shape`：

```java
public static void draw(Shape shape) { /* ... */ }
```

### Effects of Type Erasure and Bridge Methods<span style="font-size:13px;color:#909399;"> - 类型擦除的影响以及桥接方法的作用</span>

有时类型擦除会导致一些你可能未曾预料到的情况。以下示例展示了这种情况是如何发生的。以下示例展示了编译器有时会创建一个合成方法，称为桥接方法，作为类型擦除过程的一部分。

给定以下两个类：

```java
public class Node<T> {
  public T data;

  public Node(T data) { this.data = data; }

  public void setData(T data) {
    System.out.println("Node.setData");
    this.data = data;
  }
}

public class MyNode extends Node<Integer> {
  public MyNode(Integer data) { super(data); }

  public void setData(Integer data) {
    System.out.println("MyNode.setData");
    super.setData(data);
  }
}
```

如以下代码所示：

```java
MyNode mn = new MyNode(5);
Node n = mn;            // A raw type - compiler throws an unchecked warning
n.setData("Hello");     // Causes a ClassCastException to be thrown.
Integer x = mn.data;    
```

类型擦除后，此代码变为：

```java
MyNode mn = new MyNode(5);
Node n = mn;            // A raw type - compiler throws an unchecked warning
                        // Note: This statement could instead be the following:
                        //     Node n = (Node)mn;
                        // However, the compiler doesn't generate a cast because
                        // it isn't required.
n.setData("Hello");     // Causes a ClassCastException to be thrown.
Integer x = (Integer)mn.data; 
```

下一节将解释为什么在 `n.setData("Hello");` 语句处会抛出 `ClassCastException` 异常。

#### Bridge Methods<span style="font-size:13px;color:#909399;"> - 桥接方法</span>

当编译一个扩展了参数化类或实现了参数化接口的类或接口时，编译器可能需要创建一个合成方法，这种方法被称为桥接方法，作为类型擦除过程的一部分。通常你不需要担心桥接方法，但如果在堆栈跟踪中出现了一个桥接方法，你可能会感到困惑。

类型擦除后，`Node` 和 `MyNode` 类变为：

```java
public class Node {
  public Object data;

  public Node(Object data) { this.data = data; }

  public void setData(Object data) {
    System.out.println("Node.setData");
    this.data = data;
  }
}

public class MyNode extends Node {
  public MyNode(Integer data) { super(data); }

  public void setData(Integer data) {
    System.out.println("MyNode.setData");
    super.setData(data);
  }
}
```

经过类型擦除后，方法签名不再匹配；`Node.setData(T)` 方法变为 `Node.setData(Object)`。因此，`MyNode.setData(Integer)` 方法并没有覆盖 `Node.setData(Object)` 方法。

<strong style="color:#ae3520;">为了解决这个问题并*在类型擦除后保持泛型类型的多态性*，Java 编译器生成一个桥接方法以确保子类型关系按预期工作</strong>。

对于 `MyNode` 类，编译器为 `setData` 方法生成以下桥接方法：

```java
class MyNode extends Node {
  // Bridge method generated by the compiler
  public void setData(Object data) {
    setData((Integer) data);
  }

  public void setData(Integer data) {
    System.out.println("MyNode.setData");
    super.setData(data);
  }

  // ...
}
```

<strong style="color:#ae3520;">桥接方法 `MyNode.setData(Object)` 在内部会委托给子类的原始方法 `MyNode.setData(Integer)` </strong>。因此，`n.setData("Hello");` 语句实际上调用了 `MyNode.setData(Object)` 方法，并且由于 `"Hello"` 无法被转换为 `Integer` 类型，导致抛出了 `ClassCastException` 异常。

## 泛型的限制

为了有效地使用 Java 泛型，你必须考虑以下限制：

- [不能使用基本类型实例化泛型类型](#instantiate)
- [不能创建类型参数的实例](#createObjects)
- [不能声明类型为类型参数的静态字段](#createStatic)
- [不能对参数化类型使用强制转换或instanceof](#cannotCast)
- [不能创建参数化类型的数组](#createArrays)
- [不能创建、捕获或抛出参数化类型的对象](#cannotCatch)
- [不能重载方法，其中每个重载方法的形式参数类型在类型擦除后变为相同的原始类型](#cannotOverload)

### 不能使用基本类型实例化泛型类型 {#instantiate}

考虑以下参数化类型：

```java
class Pair<K, V> {
  private K key;
  private V value;

  public Pair(K key, V value) {
    this.key = key;
    this.value = value;
  }

  // ...
}
```

创建 `Pair` 对象时，不能用基本类型替换类型参数 `K` 或 `V`：

```java
Pair<int, char> p = new Pair<>(8, 'a');  // 编译时错误
```

只能用非基本类型替换类型参数 `K` 和 `V`：

```java
Pair<Integer, Character> p = new Pair<>(8, 'a');
```

请注意，Java 编译器会进行自动装箱， `8` to `Integer.valueOf(8)` 和 ' `a` ' to `Character('a')`：

```java
Pair<Integer, Character> p = new Pair<>(Integer.valueOf(8), new Character('a'));
```

### 不能创建类型参数的实例 {#createObjects}

你不能创建类型参数的实例 - <span style="font-size:13px;color:#909399;"> 这是因为类型参数 `E` 代表了一个未知的类型，你无法直接创建该类型的实例。当你声明一个类型参数 `E` 时，它仅仅是一个占位符，代表任何可能的类型。因此，你不能直接使用 `new E()` 来创建 `E` 的实例，因为编译器不知道 `E` 实际上是什么类型。</span>例如，以下代码会导致编译时错误：

```java
public static <E> void append(List<E> list) {
  E elem = new E();  // 编译时错误
  list.add(elem);
}
```

作为一种变通方法，你可以通过反射创建类型参数的实例，这种方法允许你根据运行时提供的具体类型创建实例：

```java
public static <E> void append(List<E> list, Class<E> cls) throws Exception {
  E elem = cls.newInstance();   // OK
  list.add(elem);
}
```

你可以像下面这样调用 `append` 方法：

```java
List<String> ls = new ArrayList<>();
append(ls, String.class);
```

### 不能声明类型为类型参数的静态字段 {#createStatic}

类的静态字段是类级别的变量，由类的所有非静态对象共享。因此，不允许声明类型参数的静态字段。考虑以下类：

```java
public class MobileDevice<T> {
  private static T os;

  // ...
}
```

如果允许声明类型参数的静态字段，那么以下代码会让人困惑：

```java
MobileDevice<Smartphone> phone = new MobileDevice<>();
MobileDevice<Pager> pager = new MobileDevice<>();
MobileDevice<TabletPC> pc = new MobileDevice<>();
```

因为静态字段 `os` 由 `phone`、`pager` 和 `pc` 共享，那么 `os` 的实际类型是什么？它不能同时是 `Smartphone`、`Pager` 和 `TabletPC`。因此，你不能创建类型参数的静态字段。

### 不能对参数化类型使用强制转换或instanceof {#cannotCast}

由于 Java 编译器会擦除泛型代码中的所有类型参数，你无法在运行时验证泛型类型所使用的参数化类型：

```java
public static <E> void rtti(List<E> list) {
  if (list instanceof ArrayList<Integer>) {  // 编译时错误
    // ...
  }
}
```

传递给 `rtti` 方法的参数化类型集合是：

```plaintext
S = { ArrayList<Integer>, ArrayList<String>, LinkedList<Character>, ... }
```

运行时不会跟踪类型参数，因此它无法区分 `ArrayList<Integer>` 和 `ArrayList<String>`。你能做的最多是使用无界通配符来验证列表是否为 `ArrayList`：

```java
public static void rtti(List<?> list) {
  if (list instanceof ArrayList<?>) {  // OK; instanceof 需要可重构类型
    // ...
  }
}
```

通常情况下，除非使用无界通配符参数化，否则不能对参数化类型进行类型转换。例如：

```java
List<Integer> li = new ArrayList<>();
List<Number> ln = (List<Number>) li;  // 编译时错误
```

但在某些情况下，编译器知道类型参数始终有效并允许类型转换。例如：

```java
List<String> l1 = ...;
ArrayList<String> l2 = (ArrayList<String>)l1;  // OK
```

### 不能创建参数化类型的数组 {#createArrays}

你不能创建参数化类型的数组。例如，以下代码不会编译：

```java
List<Integer>[] arrayOfLists = new List<Integer>[2];  // 编译时错误
```

以下代码演示了当不同类型的对象插入数组时会发生什么情况：

```java
Object[] strings = new String[2];
strings[0] = "hi";   // OK
strings[1] = 100;    // 抛出 ArrayStoreException
```

如果你尝试用泛型集合做同样的事情，就会出现问题：

```java
Object[] stringLists = new List<String>[2];  // 编译器错误，但假设它被允许
stringLists[0] = new ArrayList<String>();   // OK
stringLists[1] = new ArrayList<Integer>();  // 应该抛出 ArrayStoreException，
                                            // 但运行时无法检测到。
```

如果允许创建参数化集合的数组，前面的代码将无法抛出预期的 `ArrayStoreException` 异常。

### 不能创建、捕获或抛出参数化类型的对象 {#cannotCatch}

泛型类不能直接或间接继承 `Throwable` 类。例如，以下类不会编译：

```java
// 间接继承 Throwable
class MathException<T> extends Exception { /* ... */ }    // 编译时错误

// 直接继承 Throwable
class QueueFullException<T> extends Throwable { /* ... */ // 编译时错误
```

方法不能捕获类型参数的实例：

```java
public static <T extends Exception, J> void execute(List<J> jobs) {
  try {
    for (J job : jobs)
      // ...
  } catch (T e) {   // 编译时错误
    // ...
  }
}
```

但是，你可以在 `throws` 子句中使用类型参数：

```java
class Parser<T extends Exception> {
  public void parse(File file) throws T {     // OK
    // ...
  }
}
```

### 不能重载方法，其中每个重载方法的形式参数类型在类型擦除后变为相同的原始类型 {#cannotOverload}

一个类不能有两个在类型擦除后具有相同签名的重载方法。

```java
public class Example {
  public void print(Set<String> strSet) { }
  public void print(Set<Integer> intSet) { }
}
```

这些重载方法在类型擦除后将共享相同的类文件表示，并将生成编译时错误。

## 问题与练习

1. **编写一个泛型方法来计算集合中具有特定属性（例如，奇数整数、质数、回文）的元素数量。**

   ::: code-group

   ```java [Test]
   public class Test {
     public static void main(String[] args) {
       Collection<Integer> ci = Arrays.asList(1, 2, 3, 4);
       Predicate<Integer> isOdd = i -> i % 2 != 0;
       final int count = Algorithm.count(ci, isOdd);
       System.out.println("Number of odd integers = " + count);
     }
   }
   ```

   ```java [Algorithm]
   public final class Algorithm {
     public static <T> int count(Collection<T> c, Predicate<T> p) {
       int count = 0;
       for (final T item : c) {
         if (p.test(item)) {
           count++;
         }
       }
       return count;
     }
   }
   ```

   :::

2. **下面的类是否会编译？如果不编译，为什么？**

   ```java
   public final class Algorithm {
     public static <T> T max(T x, T y) {
       return x > y ? x : y;
     }
   }
   ```

   **Answer**: 不会编译。因为大于 (`>`) 操作符只能用于原始数值类型（如 `int`, `long` 等），而不能直接用于对象类型。在这个例子中，`T` 是一个类型参数，它代表一个未知的类型。因此，你不能直接使用 `x > y` 来比较两个 `T` 类型的对象。

   为了解决这个问题，你需要确保 `T` 是一个可以比较的类型，例如，你可以让 `T` 扩展 `Comparable<T>` 接口，并使用 `compareTo` 方法来进行比较。这样，你可以编写如下代码：

   ```java
   public final class Algorithm {
     public static <T extends Comparable<T>> T max(T x, T y) {
       return x.compareTo(y) > 0 ? x : y;
     }
   }
   ```

3. **编写一个泛型方法来交换数组中两个不同元素的位置。**

   ```java
   public final class Algorithm {
     public static <T> void swap(T[] arr, int i, int j) {
       T temp = arr[i];
       arr[i] = arr[j];
       arr[j] = temp;
     }
   }
   ```

4. **如果编译器在编译时擦除了所有类型参数，为什么还要使用泛型？**

   因为：

   - Java 编译器在编译时对泛型代码执行更严格的类型检查。
   - 泛型支持将类型作为参数进行编程。
   - 泛型使你能够实现通用算法。

5. **类型擦除后，下面的类会被转换成什么样子？**

   ```java
   public class Pair<K, V> {
     public Pair(K key, V value) {
       this.key = key;
       this.value = value;
     }
   
     public K getKey() { return key; }
     public V getValue() { return value; }
   
     public void setKey(K key)     { this.key = key; }
     public void setValue(V value) { this.value = value; }
   
     private K key;
     private V value;
   }
   ```

   ⤵️

   ```java
   public class Pair {
     public Pair(Object key, Object value) {
       this.key = key;
       this.value = value;
     }
   
     public Object getKey()   { return key; }
     public Object getValue() { return value; }
   
     public void setKey(Object key)     { this.key = key; }
     public void setValue(Object value) { this.value = value; }
   
     private Object key;
     private Object value;
   }
   ```

6. **类型擦除后，下面的方法会被转换成什么样子？**

   ```java
   public static <T extends Comparable<T>> int findFirstGreaterThan(T[] at, T elem) {
     // ...
   }
   ```

   ⤵️

   ```java
   public static int findFirstGreaterThan(Comparable[] at, Comparable elem) {
     // ...
   }
   ```

7. **下面的方法是否会编译？如果不编译，为什么？**

   ```java
   public static void print(List<? extends Number> list) {
     for (Number n : list)
       System.out.print(n + " ");
     System.out.println();
   }
   ```

   **Answer**: Yes.

8. **编写一个泛型方法来查找集合中指定范围 `[begin, end)` 内的最大元素。**

   ```java
   public final class Algorithm {
     public static <T extends Comparable<T>> T max(List<? extends T> list, int begin, int end) {
       if (begin < 0 || end >= list.size() || begin > end) {
         throw new IllegalArgumentException("Invalid range");
       }
       T max = list.get(begin);
       for (++begin; begin <= end; begin++) {
         final T item = list.get(begin);
         if (item.compareTo(max) > 0) {
           max = item;
         }
       }
       return max;
     }
   }
   ```

9. **下面的类是否会编译？如果不编译，为什么？**

   ```java
   public class Singleton<T> {
     public static T getInstance() {
       if (instance == null)
         instance = new Singleton<T>();
   
       return instance;
     }
   
     private static T instance = null;
   }
   ```

   **Answer**: 不会编译，因为不能创建类型为类型参数 `<T>` 的静态字段。

10. **给出以下类：**

    ```java
    class Shape { /* ... */ }
    class Circle extends Shape { /* ... */ }
    class Rectangle extends Shape { /* ... */ }
    
    class Node<T> { /* ... */ }
    ```

    **下面的代码是否会编译？如果不编译，为什么？**

    ```java
    Node<Circle> nc = new Node<>();
    Node<Shape>  ns = nc;
    ```

    **Answer**: 不会编译，因为 `Node<Circle>` 并不是 `Node<Shape>` 的子类型。

11. **考虑这个类：**

    ```java
    class Node<T> implements Comparable<T> {
      public int compareTo(T obj) { /* ... */ }
      // ...
    }
    ```

    **下面的代码是否会编译？如果不编译，为什么？**

    ```java
    Node<String> node = new Node<>();
    Comparable<String> comp = node;
    ```

    **Answer**: Yes.

12. **如何调用下面的方法来查找集合中第一个与一组指定整数互质的整数？**

    ```java
    public static <T> int findFirst(List<T> list, int begin, int end, UnaryPredicate<T> p)
    ```

    > [!note]
    >
    > 如果两个整数 a 和 b 的最大公约数（GCD）为 1，则称它们互质。

    ::: code-group

    ```java [Test]
    public class Test {
      public static void main(String[] args) {
        List<Integer> li = Arrays.asList(3, 4, 6, 8, 11, 15, 28, 32);
        Collection<Integer> c = Arrays.asList(7, 18, 19, 25);
        Predicate<Integer> p = new RelativelyPrimePredicate(c);
        int i = Algorithm.findFirst(li, 0, li.size() - 1, p);
        if (i != -1) {
          System.out.print(li.get(i) + " is relatively prime to ");
          for (Integer k : c) {
            System.out.print(k + " ");
          }
          System.out.println();
        }
      }
    
      static class RelativelyPrimePredicate implements Predicate<Integer> {
        private final Collection<Integer> c;
    
        public RelativelyPrimePredicate(final Collection<Integer> c) {
          this.c = c;
        }
    
        @Override
        public boolean test(final Integer x) {
          for (Integer i : c) {
            if (Algorithm.gcd(x, i) != 1) {
              return false;
            }
          }
          return !c.isEmpty();
        }
      }
    }
    ```

    ```java [Algorithm]
    public final class Algorithm {
      public static <T> int findFirst(List<T> list, int begin, int end, Predicate<T> p) {
        if (begin < 0 || end >= list.size() || begin > end) {
          throw new IllegalArgumentException("Invalid range");
        }
        for (; begin <= end; begin++) {
          if (p.test(list.get(begin))) {
            return begin;
          }
        }
        return -1;
      }
    
      public static int gcd(int a, int b) {
        int r;
        while ((r = a % b) != 0) {
          a = b;
          b = r;
        }
        return a;
      }
    }
    ```

    :::

    该程序打印：11 is relatively prime to 7 18 19 25

## 总结

### 通配符的使用场景及其限制

1. **上限通配符** (`List<? extends T>`): 表示集合中的元素为类型 `T` 或其子类型。<strong style="color:#ae3520;">通常用于读取集合中的元素，但不能向集合中添加任何元素（除非添加的元素为 `null`）</strong>。
2. **下限通配符** (`List<? super T>`) ：表示集合中的元素为类型 `T` 或其超类型。<strong style="color:#ae3520;">通常用于向集合中添加元素，但不能从集合中读取元素并将其赋值给具体的类型（除非是将它们赋值给 `Object` 类型的变量）</strong>。
3. **无界通配符**（`List<?>`）：表示集合中的元素可以是任意类型，正因如此，你<strong style="color:#ae3520;">不能向集合中添加任何元素（除非添加的元素为 `null`），不能从集合中读取元素并将其赋值给具体的类型（除非是将它们赋值给 `Object` 类型的变量）</strong>。

> [!important]
>
> PECS (Producer-Extends, Consumer-Super) 原则：是指当一个集合作为数据的生产者 Producer 时，应该使用 `? extends T` 来声明上界支持协变，以便获取元素。当一个集合作为数据的消费者 Consumer 时，应该使用 `? super T` 来声明下界支持逆变，以便添加元素。

`Collections` 工具类中的 `copy` 泛型方法如下所示，该方法很好地体现 PECS 原则。

```java
public static <T> void copy(List<? super T> dest, List<? extends T> src) {
  int srcSize = src.size();
  if (srcSize > dest.size())
    throw new IndexOutOfBoundsException("Source does not fit in dest");
  if (srcSize < COPY_THRESHOLD ||
      (src instanceof RandomAccess && dest instanceof RandomAccess)) {
    for (int i=0; i<srcSize; i++)
      dest.set(i, src.get(i));
  } else {
    ListIterator<? super T> di=dest.listIterator();
    ListIterator<? extends T> si=src.listIterator();
    for (int i=0; i<srcSize; i++) {
      di.next();
      di.set(si.next());
    }
  }
}
```

该方法用于将一个集合中的元素复制到另一个集合中。

- `src`：源集合，作为生产者，使用 `? extends T` 来声明上界。该集合可以提供任何 `T` 及其子类型元素，如 `src.get(i)` 所示，就是在获取该集合中提供的元素；
- `dest`：目标集合，作为消费者，使用 `? super T` 来声明下界。该集合可以接收任何 `T` 及其超类型元素，如 `dest.set(i, src.get(i))` 所示，就是在向该集合中添加元素。

这种设计在保证类型安全的同时提供了灵活性。

## 参考资料🎁

- 📃文档
  - [Lesson: Generics (Updated) (The Java™ Tutorials > Learning the Java Language) (oracle.com)](https://docs.oracle.com/javase/tutorial/java/generics/index.html)
- 📺视频
  - [《Java核心技术》 第8章：泛型编程](https://www.bilibili.com/video/BV1k341157qm?vd_source=84272a2d7f72158b38778819be5bc6ad)
  - [【每次一个技术点】为什么要用泛型](https://www.bilibili.com/video/BV1Z54y1f7RJ?vd_source=84272a2d7f72158b38778819be5bc6ad)
  - [80%人不懂的Java泛型知识](https://www.bilibili.com/video/BV1eF41147QZ?vd_source=84272a2d7f72158b38778819be5bc6ad)
  - [90%人不懂泛型局限性，泛型擦除，星投影](https://www.bilibili.com/video/BV1xN4y1M7ui?vd_source=84272a2d7f72158b38778819be5bc6ad)

 